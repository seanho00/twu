<HTML>
<HEAD>
<TITLE>10.6 An Extended Example--Fibonacci Sequences</TITLE>
<meta NAME="keywords" CONTENT="fibbonacci, sequence, example, visibility, extended, recursive, recursion, initialization, initialize, initialise, initialisation">
<meta NAME="description" CONENT="Modula-2 shareware textbook by Rick Sutcliffe: Intermediate Program Structuring">
<META NAME="Author" content="Rick Sutcliffe">
<META NAME="Copyright" content="1983-2004 Rick Sutcliffe">
<STYLE TYPE="text/css"></STYLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../linkstyles.css" TITLE="Style">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

</HEAD>

<BODY BGCOLOR="#CCFFFF">
<SCRIPT LANGUAGE="JavaScript1.1">
<!--
function framesGO() {
// figures out the path to one directory above this document
// (where the MAIN index.html is) and puts it into theString:

theString=document.URL
theString=theString.substring(0,theString.lastIndexOf("/",theString.length - 14))
parent.window.location = theString + "/index.html?" + document.URL
}

// if this is the top frame, we'll create a link to activate some
// JavaScript to set up the frames around this document.  For more
// documentation, look at the comments in the source of the top frame
// (numberstr.html in this directory - not numberstr1.html).

if ((parent.frames.length) == 0)
{
document.write('<CENTER><A HREF=\"javascript:framesGO()\">Show outer (navigation) frames</A></CENTER><HR>')
}
else
{
if (navigator.appVersion.substring(0,1) == 3 && navigator.appName.lastIndexOf('Netscape') != -1)
{
parent.frames[0].location.replace('numberstr1.html')
// For some reason netscape 3 gets confused when it tries to run the cool JavaScript
// stuff in numberstr.html and continue to load this frame at the same time. >:-(
// So, we'll load the boring numberstr1.html instead.
}
else
{
parent.frames[0].location.replace('numberstr.html')
}
}
//-->
</SCRIPT><H2><B>10.6 An Extended Example<!--</B>‹<B>-->--Fibonacci Sequences</B></H2>
<P>No attempt will be made here to illustrate all the visibility details discussed so far in this chapter in practical examples.  However, the principle that information can be kept hidden from portions of the program that do not need it is important, for code that cannot see some entities that it should not, can also not modify those entities, resulting in safer and easier-to-debug code.  The next example illustrates the use of a module (local to the program module) to generate the next number in a special sequence 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... known as the Fibonacci Sequence.</P>
<BLOCKQUOTE><I>The <U><A NAME="Fibonacci">Fibonacci</A> Sequence</U> is defined by<BR>
F<SUB>1</SUB> = 0, F<SUB>2</SUB>= 1 and F<SUB>i+1</SUB> = F<SUB>i-1</SUB> + F<SUB>i</SUB><BR>
thereafter.</I></BLOCKQUOTE>
<P>That is, after the first two numbers, all subsequent ones in the sequence are generated by adding the previous two.  In the Modula-2 solution that follows, <I>FibGen</I> has a body that initializes the sequence, and local variables to maintain the (current) ultimate and penultimate values in the sequence.  All of this is invisible to the surrounding program module, which is interested only in the exported procedure <I>NextFib</I>, and not any other details involved.</P>
<P>If the module were declared within a procedure, by the way, that initialization body would execute whenever the procedure were entered.  After all, the module would <I>exist</I> only inside the procedure, according to the scope rules for procedures.  This way, the initialization takes place once.</P>
<PRE>
<B>MODULE</B> Fibonacci;

(* by R. Sutcliffe
   To demonstrate hiding in local modules
   revised 1994 04 11 *)
 
(* This module generates and prints the first twenty numbers in the Fibonacci sequence. *)

<B>FROM</B> STextIO <B>IMPORT</B>
  WriteString, WriteLn;
<B>FROM</B> SWholeIO <B>IMPORT</B>
  WriteCard;
  
<B>PROCEDURE</B> OutputVal (index, num : <B>CARDINAL</B>);
<B>BEGIN</B>
  WriteCard (index, 2);
  WriteString (<!--"-->&quot; )  <!--"-->&quot;);
  WriteCard (num, 5);
  WriteLn;
<B>END</B> OutputVal;
(*-------------------------------------*)

<B>MODULE</B> FibGen;
<B>EXPORT</B> NextFib;
<B>VAR</B>
  ult, penult, temp: <B>CARDINAL</B>; (* hidden *)
<B>PROCEDURE</B> NextFib ( ) : <B>CARDINAL</B>;
<B>BEGIN</B>
  temp := ult;
  ult := ult + penult;
  penult := temp;
  <B>RETURN</B> ult;
<B>END</B> NextFib;

(* The module body initializes the two local variables before being used *)
<B>BEGIN</B>
  ult := 0;
  penult := 1;
<B>END</B> FibGen;

(*-------------------------------------*)

(* Main Program Starts *)
<B>VAR</B>
  fib, count : <B>CARDINAL</B>;
<B>BEGIN</B>
  WriteString(<!--"-->&quot; The first 20 Fibonacci Numbers are: <!--"-->&quot;);
  WriteLn;
  OutputVal (1, 0);
  (* the first Fib num is written out before one starts calcs *)
  <B>FOR</B> count := 2 <B>TO</B> 20
    <B>DO</B>  (* Then, the rest *)
      fib := NextFib( );
      OutputVal (count, fib);
    <B>END</B>;
  WriteString (<!--"-->&quot;There you have it <!--"-->&quot;);
<B>END</B> Fibonacci.</PRE>
<P>The output from this program was:</P>
<PRE>
 The first 20 Fibonacci Numbers are: 
 1 )      0
 2 )      1
 3 )      1
 4 )      2
 5 )      3
 6 )      5
 7 )      8
 8 )     13
 9 )     21
10 )     34
11 )     55
12 )     89
13 )    144
14 )    233
15 )    377
16 )    610
17 )    987
18 )   1597
19 )   2584
20 )   4181
There you have it </PRE>
<P>Notice how one keeps the entities being manipulated hidden from the surrounding scope and update them only through an exported procedure.  One uses the fact that <I>ult</I> and <I>penult</I> are global to <I>FibGen</I> to maintain their values between calls to the procedure <I>NextFib</I>.  However, these two variables are not visible in the outer scope and so the main program cannot change them except by calling <I>NextFib</I>.</P>
<HR>
<CENTER><A HREF="../contents.html" TARGET="big_right">Contents</A>
</CENTER>
</BODY>
</HTML>