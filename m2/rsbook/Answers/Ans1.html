<HTML>
<HEAD>
<TITLE>Chapter 1 Answer Key</TITLE>
<STYLE TYPE="text/css"></STYLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../linkstyles.css" TITLE="Style">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

</HEAD>


<BODY BGCOLOR="CCFFFF">

<SCRIPT LANGUAGE="JavaScript1.1">
<!--
function framesGO() {
// figures out the path to one directory above this document
// (where the MAIN index.html is) and puts it into theString:

theString=document.URL
theString=theString.substring(0,theString.lastIndexOf("/",theString.length - 14))
parent.window.location = theString + "/index.html?" + document.URL
}

// if this is the top frame, we'll create a link to activate some
// JavaScript to set up the frames around this document. For more
// documentation, look at the comments in the source of the top frame
// (numberstr.html in this directory - not numberstr1.html).

if ((parent.frames.length) == 0)
{
document.write('<CENTER><A HREF=\"javascript:framesGO()\">Show outer (navigation) frames</A></CENTER><HR>')
}
else
{
if (navigator.appVersion.substring(0,1) == 3 && navigator.appName.lastIndexOf('Netscape') != -1)
{
parent.frames[0].location.replace('numberstr1.html')
// For some reason netscape 3 gets confused when it tries to run the cool JavaScript
// stuff in numberstr.html and continue to load this frame at the same time. >:-(
// So, we'll load the boring numberstr1.html instead.
}
else
{
parent.frames[0].location.replace('numberstr.html')
}
}
//-->
</SCRIPT><H2><B>CHAPTER 1</B></H2>

<H3><B>Questions</B></H3>

<P>1.	Top down design is the process of solving a problem by breaking it down to successively smaller steps whose interrelationship is clearly defined and then solving each of the steps. Bottom up design is focusing on the details, then tackling each one separately, then gradually welding the partial answers into a coherent whole that provides a solution to the whole problem.</P>

<P>2.	Step 1: Write everything down. Step 2: Apprehend the problem. Step 3: Design a solution. Step 4: Execute the completed plan. Step 5: Scrutinize the results.</P>

<P>3.	Since an abstraction can be roughly defined as deliberately not knowing details, one can consider driving a car an abstraction because one does not need to know how build an automobile or know the details of how the car works in order to drive one.</P>

<P>4.	An abstraction is a task that is seen as an organic whole. Going back to the example of the logger, we see abstraction at work. Unexperienced people would detail the steps to take in order to perform the task. The professional logger however, will view it as a whole and not worry about individual steps. It is part of the professional‹a built in function.</P>

<P>5.	Answers may vary, depending on whether one believes a human has a soul, and is more than merely a body.</P>

<P>6.	Money is a medium of exchange that represents an underlying value; it has no value except by mutual agreement.</P>

<P>7.	A paradigm is a way of looking at something by way of analogy or example. 
	A model is a representation in more concrete or accessible form than the original. The word may also be also used of a scale model for some proposed project.
	A world view is a complete set of philosophic or religious presuppositions within which paradigms and individual abstractions are formed. 
		A meme is a transmittable idea that is the basis of a social movement or a political philosophy.</P>

<P>8.	Answers may vary.</P>

<P>9.	Data abstractions.
		--data representation abstractions (data structures).
		--data manipulation abstractions (expression structure).
	Machine abstractions.
		--the computing apparatus itself (machine structures)
		--the instruction and manipulation of the machine (program structures).</P>

<P>10.	Data is a conglomerate of facts that has been collected,  and has no particular meaning. Infomation is data that has been assigned a particular meaning. It is useful data that can be understood and applied.</P>

<P>11.	(a)	compound
	(b)	atomic
	(c)	compound
	(d)	compound
	(e)	atomic
	(f)	compound</P>

<P>12.	(a)	real
	(b)	unsigned whole number
	(c)	compound : pair of unsigned whole numbers
	(d)	string
	(e)	signed whole number
	(f)	boolean
	(g)	unsigned whole number
	(h)	real
	(i)	boolean
	(j)	compound: set of whole numbers
	(k)	depends on the type of y2 and y1</P>

<P>13.	An ADT is a specified set of items with certain properties and operations in comon.</P>

<P>14.	There is a difference because of the limitation of the hardware. For some types, such as whole numbers, the abstract set is of infinite size. Abstract reals also have infinite precision. Neither property can be expressed in finite hardware.</P>

<P>15.	A variable is a name whose value is subject to change during a course of a computation whereas a constant names a value that is fixed.</P>

<P>16.	An expression is a combination of data items with various operators that are available for that data type. An expression is assigned a type according to the type of data produced when the expression is evaluated.</P>

<P>17.	The major tasks of computing hardware are:  (i) input  (ii) memory  (iii) processing (iv) control  (v) output</P>

<P>18.	Read Only Memory is permanently coded into a memory chip at the time of manufacturing. It never loses its data when power to the chip is lost. Random Access Memory contains data that is temporarily stored and can be changed. It loses its data if power is lost.</P>

<P>19.	Hardware is the physical components,  including the electronics, that make up the computer itself. Firmware are the programs that are coded into ROM chips at time of manufacturing.</P>

<P>20.	The virtual machine is the total environment presented to the user by the combination of hardware and software  being employed at the moment.</P>

<P>21.	The major task of the OS is to handle the disk drives and other I/O devices , and to provide an interface for programs.</P>

<P>22.	Niklaus Wirth invented Pascal Modula-2, and Oberon.</P>

<P>23.	COBOL is the language principally used for business applications.</P>

<P>24.	A compiler is a program that takes code in text form text and translates it into machine language a single time for later execution. An interpreter is a program that translates into machine code as the program is run and every time it is run.</P>

<P>25.	Sequence:  one instruction following another in order.
	Selection:  the choice among two or more alternative tasks depending on circumstances encountered when the solution is executed.
	Repetition/Iteration:  a series of steps under the control of some condition (also known as a loop). There are 2 kinds‹top-of-loop tested and bottom-of-loop tested.
	Composition:  letting the name of some code stand for the whole; one command containing a number of sequenced steps.
	Parallelism:  The ability for code to be implemented on many processing devices simultaneously.</P>

<P>26.	In top-of-loop testing, the test for exiting is  made in the beginning of the loop. For example, a WHILE loop tests if the condition is met then proceeds if it is. However in a bottom-of-loop testing, the test is considered at the end of the loop, as in a REPEAT loop.</P>

<P>27.	The advantage of writing programs in pseudocode before actual coding is as follows:
	(i)	One need not pay particular attention at this stage to the specific grammatical details of the actual code in a particular notation.
	(ii)	The pseudocode is general enough so that the solution can later be expressed in any one of several different actual coding notations.
	(iii)	Writing in pseudocode forces the programmer to pay sufficient attention to detail to ensure that the solution is completely thought out.
	(iv)	The pseudocode is easy to examine for possible efficiency imporvements and for the elimination of logical errors.</P>

<P>28.	An algorithm is a technique to solve a problem expressed as a series of steps or instructions.</P>

<P>29.	The syntax of a programming notation consists of a set of legal symbols, together with the grammatical rules expressing how those symbols may be employed to write correct programs. Sematics on the other hand is the meaning of code, either in the context of the notation or in that of a program.</P>

<P>30.	Syntax errors are errors caused by incorrect spelling, misplaced or missing punctuation (such as semicolons ) or otherwise incorrect use of some part of the notation. It can be prevented by good proof reading.</P>
<P>	Logical errors are caused by insufficient planning, fuzzy thinking, or poor program orgainztion. They are also caused by a failure to express the meaning of the problem in a fashion that can be translated into a solution. These can be corrected by good planning, organization, and development.</P>

<H3><B>Problems</B></H3>

<P>31.	(a) 522		(b) -0.8		(c) 47		(d) true
	(e) true 		(f) false 	
	(g) bad expression:  mixed whole and boolean
	(h) bad expression:  mixed whole and real
	(i) bad expression:  mixed boolean and whole	(j) 7.0</P>

<P>32.	<pre>	start at zero
	set a counter to zero
	while counter < 20 
	  set number variable to counter times itself
	  print counter
	  increase counter by 1
	end while</pre></P>

<P>33.	<pre>	read in number
	if number mod 2 = 0
	  even
	else
	  odd</pre></P>

<P>34.	<pre>	Pass01:	1, 1
	Pass02:	2, 1
		<!--	-->2, 2
	Pass03:	3, 1
		<!--	-->3, 2
		<!--	-->3, 3
	.
	.
	.
	Pass10:	10, 1
		<!--	-->.
		<!--	-->.
		<!--	-->.
		<!--	-->10, 10</pre></P>

<P>35.	<pre>	SumOfNSquares
	  ask user for number
	  read number
	  set counter to 1
	  set sum of square to 0
	  while counter <= number
	    add counter * counter to sum of square
	    increase counter by 1
	  end while
	end SumOfNSquares</pre></P>

<P>36.	<pre>	SumOf10
	  set counter to 1
	  set sum to 0
	  while counter <= 10
	    read n
	    add n to sum
	    increase counter by 1
	  end while
	end SumOf10</pre></P>

<P>37.	<pre>	SumOfN
	  ask user for number
	  read number
	  set counter to 1
	  set sum to 0
	  while counter <= number
	  add counter to sum
	  increase counter by 1
	  end while
	end SumOfN</pre></P>

<P>38.	<pre>	SumNSumofSquare
	  ask user for number
	  read number
	  set counter to 1
	  set sum to 0
	  set sum of square to 0
	  while counter <= number
	    add counter to sum
	    add counter * counter to sum of square
	    increase counter by 1
	  end while
	end SumNSumofSquare</pre></P>

<P>39.	<pre>	Sort3
	  set counter to 1
	  if first > second
	    set temp to second
	    set second to first
	    set first to temp
	  end if
	  if first > third
	    set temp to third
	    set third to first
	    set first to temp
	  end if
	  if second > third
	    set temp to third
	    set third to second
	    set second to temp
	  end if
	end Sort3</pre></P>

<P>40.	<pre>	compute average
	  read n (* number of reals to do *)
	  set count to 1
	  set partial sum to 0
	  while count <= n
	    read currentReal
	    add currentReal to partial sum
	    add 1 to count
	  end while
	  set average to partial sum/ <b>n</b>
	  write out average
	end compute average</pre></P>

<P>41.	<pre>	FindSequence
	  set total to number of items
	  fetch first number
	  set small to first number
	  set large to first number
	  set counter to 2
	  while counter <= total
	    fetch current number
	    if current number < small
	      set small to current
	    end if
	    if current number > small
	      set large to current
	    end if
	    increase counter by 1
	  end while
	end Find Sequence</pre></P>

<P>42.	<pre>	LargeNSmall
	  read n
	  set count to 0
	  set sum to 0
	  fetch first number
	  set largest to first
	  set smallest to first
	  while count <= n
	    read current
	    add current to sum
	    if current > LargestNumber
	      set LargestNumber to current
	    end if
	    if current < SmallestNumber
	      set SmallestNumber to current
	    end if
	    increase count by 1
	  end while
	  set average to sum/n
	  print average
	  print LargestNumber
	  print SmallestNumber
	end LargeNSmall</pre></P>

<P>43.	<pre>	MatrixAddition
	  set row to 0
	  set col to 0
	  set sum to 0
	  while row < 3
	    while col < 5
	      set sum to sum + matrix[row,  col]
	      increase col by 1
	    end while
	    increase row by 1
	  end while
	end MatrixAddition</pre></P>

<P>44.	<pre>	MatrixAddition
	  set row to 0
	  set col to 0
	  set sum to 0
	  read numrows
	  read numcols
	  while row < numrows
	    while col < numcols
	      set sum to sum + matrix[row, col]
	      increase col by 1
	    end while
	    increase row by 1
	  end while
	end MatrixAddition</pre></P>

<P>45.	<pre>	Project
	  set index to 1
	  while index <= 12
	    set b(index) to a(index) * 1.05
	    increase index by 1
	  end while

	  (* or using a matrix more explicitly
	  set index to 1
	  while index <= 12
	    set table(b, index) to table(a, index) * 1.05
	    increase index by 1
	  end while *)

	end Project</pre></P>

<P>46.	<pre>	3Fields
	  set row to 1
	  set col to 1
	  while row <= lastItemNumber
	    set table(row, col+2) to table(row, col) - table(row, col+1)
	    increase row by 1
	  end while

	  (* or, if the columns are labeled, use
	  set table(row, netprofit) to table(row, reverse) - table(row, expense)
	  without a column variable *)

	end 3Fields</pre></P>

<P>47.	<pre>	3FieldsB
	  set row to 1
	  set col to 1
	  while row <= lastItemNumber
	    set table(row, col+1) to table(row, col) * 0.07
	    set table(row, col+2) to table(row, col) + table(row, col+1)
	    increase row by 1
	  end while

	  (* same option will apply for question 46 *)

	end 3FieldsB</pre></P>

</BODY>

</HTML>