<HTML>
<HEAD>
<TITLE>3.3 Boolean Variables and Expressions</TITLE>
<meta NAME="keywords" CONTENT="bool, boolean, variable, variables, expression, expressions, if, elsif, else, true, false, relation, relational, operator, operators, connectives, connective, pseudocode, flag">
<meta NAME="description" CONENT="Modula-2 shareware textbook by Rick Sutcliffe: Basic Pogram Structure Abstractions">
<META NAME="Author" content="Rick Sutcliffe">
<META NAME="Copyright" content="1983-2004 Rick Sutcliffe">
<STYLE TYPE="text/css"></STYLE>
<STYLE TYPE="text/css"></STYLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../linkstyles.css" TITLE="Style">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

</HEAD>

<BODY BGCOLOR="#CCFFFF">
<SCRIPT LANGUAGE="JavaScript1.1">
<!--
function framesGO() {
// figures out the path to one directory above this document
// (where the MAIN index.html is) and puts it into theString:

theString=document.URL
theString=theString.substring(0,theString.lastIndexOf("/",theString.length - 14))
parent.window.location = theString + "/index.html?" + document.URL
}

// if this is the top frame, we'll create a link to activate some
// JavaScript to set up the frames around this document.  For more
// documentation, look at the comments in the source of the top frame
// (numberstr.html in this directory - not numberstr1.html).

if ((parent.frames.length) == 0)
{
document.write('<CENTER><A HREF=\"javascript:framesGO()\">Show outer (navigation) frames</A></CENTER><HR>')
}
else
{
if (navigator.appVersion.substring(0,1) == 3 && navigator.appName.lastIndexOf('Netscape') != -1)
{
parent.frames[0].location.replace('numberstr1.html')
// For some reason netscape 3 gets confused when it tries to run the cool JavaScript
// stuff in numberstr.html and continue to load this frame at the same time. >:-(
// So, we'll load the boring numberstr1.html instead.
}
else
{
parent.frames[0].location.replace('numberstr.html')
}
}
//-->
</SCRIPT><H2><B>3.3 Boolean Variables and Expressions</B></H2>
<P>In summary, the most general form of the IF ... THEN ... ELSIF ... ELSE construction as used in the previous section is as follows:</P>
<PRE>
  <B>IF</B> (Boolean Expression 1)
    <B>THEN</B>
      Statement Sequence 1;
    <B>ELSIF</B> (Boolean Expression 2) <B>THEN</B>
      Statement Sequence 2;
  ...

    <B>ELSIF</B> (Boolean Expression n) <B>THEN</B>
      Statement Sequence n;
    <B>ELSE</B>
      Statement Sequence n + 1;
    <B>END</B>;</PRE>

<P>All the ELSIFs and the ELSE are optional, depending on the logic required by the program.  Note that the form (<I>Boolean Expression i</I>)  is used here instead of a specific comparison as in all the examples thus far.</P>
<P>There was a brief discussion of Boolean expressions in <A HREF="../Ch1/Ch1.7.html">section 1.7</A>.  The purpose of this section is to specify more exactly what constitute valid boolean expressions in Modula-2, for much more elaborate ones than these can be used in a variety of program structures.</P>
<P>This brings us to the question you may have been ready to ask when you read the heading for this section and the first IF.  <!--"-->&quot;What exactly is this thing called a <!--"-->&quot;Boolean expression<!--"-->&quot;?  Two related definitions are useful:</P>
<BLOCKQUOTE><I><A NAME="Boolean">An</A> Modula-2 expression is of type BOOLEAN if it can be evaluated unambiguously as <!--"-->&quot;true<!--"-->&quot; or <!--"-->&quot;false<!--"-->&quot;. </BLOCKQUOTE>
<BLOCKQUOTE>A Modula-2 variable of type BOOLEAN can have one of the two values TRUE, or FALSE (all three words are standard identifiers). </I></BLOCKQUOTE>
<P>Previous examples have already illustrated the use of the reserved symbols = and <!--<-->&lt;<!-->&gt; (or #) used as comparisons to form boolean expressions and the reserved words OR and AND as connectives to combine two boolean expressions.  Here is a complete list of reserved words and symbols for such expressions, together with a translation.</P>
<P><U>Relational operators</U></P>
<Pre>	=		equals
	<!--<-->&lt;		less than
	<!-->&gt;		greater than
	<!--<-->&lt;=		less than or equal to
	<!-->&gt;=		greater than or equal to
	<!--<-->&lt;<!-->&gt; or #		not equal</Pre>
<P><U>Other operators</U> (connectives)</P>
<Pre>	AND or <!--&-->&amp;	both of the conditions must be true
	OR		at least one of the conditions must be true
	NOT or ~	reverses the value of the following logical expression</Pre>

<P>As in other Modula-2 expressions, any combination of these is allowed, and parentheses can be used to change the natural order of evaluation.  Here are a few examples to review the use of these:</P>

<PRE><U>Expression</U>                       	<U>BOOLEAN Value</U>

5 <!--<-->&lt;= 5                               	<B> TRUE</B>
(10 <!--<-->&lt; 5) <B>AND</B> (3 <!--<-->&lt; 4)               	 <B>FALSE</B>
('Y' = 'y') <B>OR FALSE</B>            	<B>FALSE</B>
<B>NOT</B> (5 = 6)                         	 <B>TRUE</B>
(4 = 5) <B>AND</B> ((3 = 7) <B>OR</B> <B>TRUE</B>)        	<B>FALSE</B></PRE>

<P><B>NOTES</B>: 1. The order of evaluation is:</P>
<Pre>		First	NOT (~)
		Second	*, /, DIV, MOD, AND (<!--&)-->&amp;)
		Third	+, -, OR
		Last	the relational operators =, <!--<-->&lt;<!-->&gt; (or #), <!-->&gt;, <!-->&gt;=, <!--<-->&lt;, <!--<-->&lt;=</Pre>
<P>	2. When evaluation reaches an AND, if the left expression is FALSE, the right expression is not evaluated.  Likewise, if evaluation reaches an OR, if the left expression is TRUE the right expression is not evaluated.  Most computer languages cannot be relied upon to take these shortcuts and may evaluate all parts of every boolean expression.  Another more formal way of putting this is to say that if p and q are Modula-2 boolean expressions, then:</P>

<P>		p AND q means:  IF p THEN q ELSE FALSE</P>
<P>		p OR q means:  IF p THEN TRUE ELSE q</P><P></P>
<P>	3. Expressions separated by AND or OR should be enclosed in parentheses.  If this is not done, the correct order of evaluation may not be followed, for the statement may not be syntactically correct.  If x, y, and z are numbers, then</P>

<P>		x <!--<-->&lt; y <B>AND</B> y <!-->&gt; z is illegal, but</P>
<P>		(x <!--<-->&lt; y) <B>AND</B> (y <!-->&gt; z)  is correct,</P><P></P>
<P>	because the compiler would attempt to use the proper order of operations and attempt to interpret the first of these  as x <!--<-->&lt; (y AND y) <!-->&gt; z which makes no sense at all.</P>
<P>Here are some further examples to illustrate these rules. </P>
<H3><B>Example 1.</B></H3>
<P>(6 <B>DIV</B> 3 + 2 = 5) <B>OR NOT</B> (5 <!--<-->&lt;= 7) <!--& -->&amp; (3 <!--<-->&lt; 10)</P>
<P>would be evaluated as:</P>
<P>(6 <B>DIV</B> 3 + 2 = 5) <B>OR FALSE</B> <!--& -->&amp; (3 <!--<-->&lt; 10)</P>
<P>         (2 + 2 = 5) <B>OR FALSE</B> (<!--& -->&amp; not evaluated)</P>
<P>               (4 = 5) <B>OR FALSE</B></P>
<P>                       <B>FALSE</B> </P>
<H3><B>Example 2.</B></H3>
<P><B>IF</B> (a <!--<-->&lt; b) <B>OR</B> ((c <!--<-->&lt; d) <B>AND</B> ((y <!-->&gt; 0) <B>OR</B> (b - a <!--<-->&lt; 0.05))</P>
<P>Should a in fact be less than b the entire portion on the right of the OR will not be evaluated as the left side alone would be sufficient to give a value of TRUE for the whole expression.</P>
<H3><B>Example 3.</B></H3>
<P><B>IF</B> (false expression) <B>AND</B> (enormous expression several lines long);</P>
<P>In this case, <I>enormous expression</I> will not be evaluated, again saving considerable time when the code runs.</P>
<P>As indicated above, there are boolean variables in Modula-2 as well as boolean expressions.  These are declared like those of any other type, under a VAR heading.  They may then be used throughout the program to represent various boolean values.  As usual, declaring one of these names does not give it to any particular value<!--‹-->--the variable must be initialized before it is known to be either TRUE or FALSE; until then it is undefined.  Here is a little program which offers the user a sample choice between two actions and stores the information from the choice in as the value of a boolean variable:</P>
<H3><B>Example 4.</B></H3>
<P>Two groups of students are taking a course in Modula-2 at the same time.  The Cmpt141 students have High School computing with high marks and so do a four semester hour course.  The Cmpt 143 students attend the same lectures, but have a previous university level course in Pascal.  Because it is much easier to learn a second computing notation at this level than a first, these students receive two semester hours credit.  They are also exempt from a major assignment.  Their marks are calculated as follows:</P>
<P>	CMPT 141	CMPT 143</P>
<P>Labs	25% 	(All must be done to gain credit) 25%</P>
<P>Midterms	30%	35%</P>
<P>Major Paper	10%  (essay)	Not required</P>
<P>Final Exam	35%	40%</P>
<P>The task is to write a program that will take the percentage marks from the three or four categories and produce a final percentage grade for the course.  In what follows, much of the planning has been left out for the sake of brevity.</P>
<H3><B>Pseudocode:</B></H3>
<PRE>  Print an informative heading
  Initialize the student's totalMark to zero
  Print a prompt asking which course the student is taking
  Set the value of the boolean variable in141 using the answer
  Print a prompt asking if all assignments were handed in
  Set the boolean variable assignOK using the answer
  IF assignOK then
    Print a prompt asking for the lab percentage
    Read the result to the real variable labs
    Set totalMark to 0.25*(labs)
    Print a prompt asking for the midterm percentage
    Read the result to the real variable midterms
    Print a prompt asking for the final exam percentage
    Read the result to the real variable fExam
    If in141 then
      Print a prompt asking for the essay percentage
      Read the result to the real variable essay
      totalMark = totalMark+.3*(midterms)+.35*(fExam)+.1*(essay)
    Else
      totalMark = totalMark+.35*(midterms)+.4*(fExam)
  Print the final mark embedded in a course-specific message
  If Not (assignOK) Then
    Print an explanation</PRE>

<P>In addition, the code presented here implements a common technique to allow for a repetition of the entire program at the request of the user.  This also employs a boolean variable.</P>
<PRE>
<B>MODULE</B> Modula2CourseMarks;

(* Written by R.J. Sutcliffe *)
(* to illustrate the use of Boolean variables *)
(* using P1 Modula-2 for the Macintosh computer *)
(* last revision 1993 02 12 *)

<B>FROM</B> STextIO <B>IMPORT</B>
  WriteString, WriteLn, ReadChar, SkipLine;

<B>FROM</B> SRealIO <B>IMPORT</B>
  ReadReal, WriteFixed;
    
<B>CONST</B>
  labWt = 0.25;
  midtermWt141 = 0.3;
  midtermWt143 = 0.35;
  finalWt141 = 0.35;
  finalWt143 = 0.4;
  essayWt = 0.1;

<B>VAR</B>
  labs, midterms, essay, fExam, totalMark : <B>REAL</B>;
  answer, cr : <B>CHAR</B>;
  in141, assignOk, again : <B>BOOLEAN</B>;

<B>BEGIN</B>
  WriteString (<!--"-->&quot;Modula2CourseMarks written by R.J. Sutcliffe<!--"-->&quot;);
  WriteLn;
  WriteString (<!--"-->&quot;as an example in the use of Boolean variables<!--"-->&quot;);
  WriteLn;
  WriteLn;
  WriteString (<!--"-->&quot;It computes the final percentage mark for <!--"-->&quot;);
  WriteLn;
  WriteString (<!--"-->&quot;students enrolled in Cmpt 141 and Cmpt 143. <!--"-->&quot;);
  WriteLn;
  WriteLn;
  again := <B>TRUE</B>;
  <B>WHILE</B> again
    <B>DO</B>
      totalMark := 0.0;

      (* Gather the information from the user *)
      WriteString (<!--"-->&quot;Is the student in Cmpt141? Y/N ==<!-->&gt; <!--"-->&quot;);
      ReadChar (answer);
      SkipLine;  (* consume the carriage return after the char *)
      WriteLn;
      in141 := (answer = <!--"-->&quot;Y<!--"-->&quot;) <B>OR</B> (answer = <!--"-->&quot;y<!--"-->&quot;);
      WriteString (<!--"-->&quot;Were all assignments complete? (Y/N) ==<!-->&gt; <!--"-->&quot;);
      ReadChar (answer);  (* Note that variables can be re-used *)
      SkipLine;  (* consume the carriage return after the char *)
      WriteLn;
      assignOk := (answer = <!--"-->&quot;Y<!--"-->&quot;) <B>OR</B> (answer = <!--"-->&quot;y<!--"-->&quot;);
      <B>IF</B> assignOk
        <B>THEN</B> 
          WriteString (<!--"-->&quot;What % mark was earned on labs? ==<!-->&gt; <!--"-->&quot;);
          ReadReal (labs);
          SkipLine;  (* consume the carriage return after real *)
          WriteLn;
          totalMark := labWt * labs;
          WriteString (<!--"-->&quot;What was the midterm mark? ==<!-->&gt; <!--"-->&quot;);
          ReadReal (midterms);
          SkipLine;
          WriteLn;
          WriteString (<!--"-->&quot;What was the final exam mark? ==<!-->&gt; <!--"-->&quot;);
          ReadReal (fExam);
          SkipLine;
          WriteLn;
          <B>IF</B> in141
            <B>THEN</B>
              WriteString (<!--"-->&quot;What mark was the essay mark? ==<!-->&gt; <!--"-->&quot;);
              ReadReal (essay);
              SkipLine;
              WriteLn;
              totalMark := totalMark + midtermWt141 * midterms
               + finalWt141 * fExam + essayWt * essay;
            <B>ELSE</B>
              totalMark := totalMark + midtermWt143 * midterms
               + finalWt143 * fExam;
            <B>END</B>; (* if in141 *)
        <B>END</B>; (* if assignOk *)
          
      (* print the result *)
      WriteString (<!--"-->&quot;The final mark for Cmpt<!--"-->&quot;);
      <B>IF</B> in141
        <B>THEN</B>
          WriteString (<!--"-->&quot; 141 <!--"-->&quot;);
        <B>ELSE</B>
          WriteString (<!--"-->&quot; 143 <!--"-->&quot;);
        <B>END</B>;
      WriteString (<!--"-->&quot; was <!--"-->&quot;);
      WriteFixed (totalMark, 2, 0);
      WriteString (<!--"-->&quot;%.<!--"-->&quot;);
      WriteLn;
      <B>IF</B> <B>NOT</B> assignOk
        <B>THEN</B>
          WriteString (<!--"-->&quot;No credit when assignments not done.<!--"-->&quot;);
          WriteLn;
        <B>END</B>;

      WriteLn;
      WriteString ( <!--"-->&quot;Do another calculation? Y/N ==<!-->&gt; <!--"-->&quot;);
      ReadChar (answer);
      again := (answer = <!--"-->&quot;Y<!--"-->&quot;) <B>OR</B> (answer = <!--"-->&quot;y<!--"-->&quot;);
      SkipLine;
      WriteLn;
    <B>END</B>; (* of the while loop *)

<B>END</B> Modula2CourseMarks.</PRE>

<P>Here is a run from this module:</P>
<PRE>
Modula2CourseMarks written by R.J. Sutcliffe
as an example in the use of Boolean variables

It computes the final percentage mark for 
students enrolled in Cmpt 141 and Cmpt 143. 

Is the student in Cmpt141? Y/N ==<!-->&gt; <B>Y</B>
Were all assignments complete? (Y/N) ==<!-->&gt; <B>Y</B>
What % mark was earned on labs? ==<!-->&gt; <B>100</B>
What was the midterm mark? ==<!-->&gt; <B>90</B>
What was the final exam mark? ==<!-->&gt; <B>85</B>
What mark was the essay mark? ==<!-->&gt; <B>72.5</B>
The final mark for Cmpt 141  was  89.00%.

Do another calculation? Y/N ==<!-->&gt; <B>Y</B>
Is the student in Cmpt141? Y/N ==<!-->&gt; <B>N</B>
Were all assignments complete? (Y/N) ==<!-->&gt; <B>N</B>
The final mark for Cmpt 143  was  0.00%.
No credit when assignments not done.

Do another calculation? Y/N ==<!-->&gt; <B>N</B></PRE>

<P>In programs like this, one sets a boolean from keyboard input and then uses the value one or more times to determine which course to take through the code.</P>
<BLOCKQUOTE><I><A NAME="Flag">When</A> the value of a boolean variable is used one or more times to determine the appropriate path through a program, the variable is called a <U>flag</U>. </I></BLOCKQUOTE>
<P><B>NOTE</B>:  It is redundant, superfluous, and too much excess of unnecessary extra code to write IF <I>assignOk = TRUE</I> when it suffices to use <I>IF assignOk</I>.</P>
<HR>
<CENTER><A HREF="../contents.html" TARGET="big_right">Contents</A>
</CENTER>
</BODY>
</HTML>