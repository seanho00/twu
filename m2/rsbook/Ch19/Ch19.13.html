<HTML><HEAD><TITLE>19.13 On the Use of Programming Paradigms</TITLE><STYLE TYPE="text/css"></STYLE>

<meta NAME="description" CONENT="Modula-2 shareware textbook by Rick Sutcliffe; Programming Paradigms">
<META NAME="Author" content="Rick Sutcliffe">
<META NAME="Copyright" content="1983-2004 Rick Sutcliffe">
<STYLE TYPE="text/css"></STYLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../linkstyles.css" TITLE="Style">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

</HEAD>
<BODY BGCOLOR="#CCFFFF">
<SCRIPT LANGUAGE="JavaScript1.1">
<!--
function framesGO() {
// figures out the path to one directory above this document
// (where the MAIN index.html is) and puts it into theString:
theString=document.URL
theString=theString.substring(0,theString.lastIndexOf("/",theString.length - 14))
parent.window.location = theString + "/index.html?" + document.URL
}
// if this is the top frame, we'll create a link to activate some
// JavaScript to set up the frames around this document.  For more
// documentation, look at the comments in the source of the top frame
// (numberstr.html in this directory - not numberstr1.html).
if ((parent.frames.length) == 0){
document.write('<CENTER><A HREF=\"javascript:framesGO()\">Show outer (navigation) frames</A></CENTER><HR>')}else
{if (navigator.appVersion.substring(0,1) == 3 && navigator.appName.lastIndexOf('Netscape') != -1){
parent.frames[0].location.replace('numberstr1.html')
// For some reason netscape 3 gets confused when it tries to run the cool JavaScript
// stuff in numberstr.html and continue to load this frame at the same time. >:-(
// So, we'll load the boring numberstr1.html instead.
}else{parent.frames[0].location.replace('numberstr.html')}}
//-->
</SCRIPT>
<H2><b>19.13 On the Use of Programming Paradigms</b></H2>

<P>With the inclusion of object oriented techniques in the repertoire, the programmer has the ability to produce code in a number of styles. It would be a good idea to ask when a given style of programming is appropriate, and when a different one should be used. Here are a few suggestions:</P>

<P><b>Monolithic style:</b><BR>
<i>All the code is in a single compilation unit, and there are few or no procedures.</i></P>
<P><i>Advantages:</i> There is less writing to do because there are few or no imports; the style is simple; and the program may link and run rather quickly without the overhead of libraries and procedure calls. All the code is available to the programmer for debugging.</P>
<P><i>Disadvantages:</i> This method does not scale well even to medium sized programs, much less to large ones. Debugging time goes up dramatically with the length of the single program. All code has to be produced by the writer for each program.</P>
<P><i>When to use:</i> Use for one-of-a-kind simple throw-away programs to do a calculation or simple data manipulation, where reusability is not a concern, and the program is less than a hundred lines.</P>

<P><b>Modular style:</b><BR>
<i>Code is grouped into procedures and modules according to its type relationship and/or functionality.</i></P>
<P><i>Advantages:</i> Modular design scales well even to very large programs. When used to hide data intelligently, static modules are a good tool to factor code into manageable packets that can be designed and debugged quickly and efficiently. This method can be used for the vast majority of programming needs. Existing libraries can be imported, and new ones written that may, if well designed, be reusable.</P>
<P><i>Disadvantages:</i> Static modules in themselves do not well serve the need for dynamic data. Pointers used for dynamic allocation are notorious for being error prone, even when encapsulated into libraries. Some code has to be rewritten many times for just minor changes in data.</P>
<P><i>When to use:</i> Use for programs of any size or complexity, from hundreds to millions of lines of code.</P>

<P><b>Generic style:</b><BR>
<i>Some code is parameterized, particularly as to a data type.</i></P>
<P><i>Advantages:</i> This method extends the idea of static modules to solve a particular kind of problem. Code for common structures such as lists or routines such as sorts can be written once, and then easily specialized for a particular type of data.</P>
<P><i>Disadvantages:</i> This is still a static method. It does not address the problems associated with the safety of dynamic data.</P>
<P><i>When to use:</i> Use in those cases where a data type such as a list has all its code common regardless of the type of data going into the structure, or when a routine such as a sort has common code regardless of what data is being sorted. Generic templates can be refined for the particular types with a minimum of effort.</P>

<P><b>Object Oriented style:</b><BR>
<i>The core of the program's focus is on classes of data; actions are secondary to data.</i></P>
<P><i>Advantages:</i> This method allows for a different view of problems that are data-centric. Like modular and generic techniques, it promotes the reusability of code by handing off responsibility for some actions to other data classes. If traced classes are used, many problems with pointers vanish, as memory does not need to be manually managed.</P>
<P><i>Disadvantages:</i> Object oriented programming has a greater overhead in planning, and its code runs slower than conventional procedure calls. If care is not taken in the management of objects, the tangle of data relationships can produce a kind of spaghetti approach to problem solving that rivals that found in languages employing GOTO for transfer of control</P>
<P><i>When to use:</i> Use in those cases where there are related classes of data that lend themselves naturally to a class hierarchy, and/or as a means to avoid the problems of dynamic data associated with pointers. Object oriented programming combines well with generic approaches, and the two are often used together.</P>


<HR>
<CENTER><A HREF="../contents.html" TARGET="big_right">Contents</A>
</CENTER>
</BODY>
</HTML>