<HTML>
<HEAD>
<TITLE>6.7 Modules and Design Considerations</TITLE>
<meta NAME="keywords" CONTENT="design, consider, consieration, considerations, symbol, symbolic, file, files, compile, compiler, compiled, link, linked, key, keys, decomposed, implementation, implement, module, modules, dependencies, definition, library, linking, link, run, time, run-time, incompatible, backup, back-up, backup">
<meta NAME="description" CONENT="Modula-2 shareware textbook by Rick Sutcliffe: Program Orginization and Modules">
<META NAME="Author" content="Rick Sutcliffe">
<META NAME="Copyright" content="1983-2004 Rick Sutcliffe">
<STYLE TYPE="text/css"></STYLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../linkstyles.css" TITLE="Style">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

</HEAD>

<BODY BGCOLOR="#CCFFFF">
<SCRIPT LANGUAGE="JavaScript1.1">
<!--
function framesGO() {
// figures out the path to one directory above this document
// (where the MAIN index.html is) and puts it into theString:

theString=document.URL
theString=theString.substring(0,theString.lastIndexOf("/",theString.length - 14))
parent.window.location = theString + "/index.html?" + document.URL
}

// if this is the top frame, we'll create a link to activate some
// JavaScript to set up the frames around this document. For more
// documentation, look at the comments in the source of the top frame
// (numberstr.html in this directory - not numberstr1.html).

if ((parent.frames.length) == 0)
{
document.write('<CENTER><A HREF=\"javascript:framesGO()\">Show outer (navigation) frames</A></CENTER><HR>')
}
else
{
if (navigator.appVersion.substring(0,1) == 3 && navigator.appName.lastIndexOf('Netscape') != -1)
{
parent.frames[0].location.replace('numberstr1.html')
// For some reason netscape 3 gets confused when it tries to run the cool JavaScript
// stuff in numberstr.html and continue to load this frame at the same time. >:-(
// So, we'll load the boring numberstr1.html instead.
}
else
{
parent.frames[0].location.replace('numberstr.html')
}
}
//-->
</SCRIPT>
<H2><B>6.7 Modules and Design Considerations</B></H2>
<P>In order to understand the points being made about design in this section, it is necessary to know something about what happens when the various kinds of modules are compiled<!--‹-->--for each of the three compiles in a somewhat different way.</P>
<P>As previously noted, when a definition module is compiled, a <I>symbol file</I> of the various entities with their syntax is created so that compilations of client programs can reference the entities defined. At the same time, a unique identification key is generated by the compiler and placed in the symbol file. If that particular definition module is ever re-compiled for any reason, the new key generated will be different from the old one.</P>
<P><B>Exception:</B>  Some compilers ignore comments to the extent that changing only these does not produce a new key on recompilation. Do not count on this fact.</P>
<P><B>NOTE</B>:	The definition of Modula-2 does not <I>require</I> that the symbol file be separate from the definition module source code; an implementation might choose to keep the module key with the source and do nothing else. Then, the source would also be the symbol file.</P>
<P>When the implementation part of a library module is compiled, the disk is searched for the symbol file of the corresponding definition part. For the compilation to be successful, the syntax of the various entities must match. For instance, a procedure heading that is given in the definition part and then altered, say, as to the number and type of parameters, or omitted in the implementation, would cause compilation of the implementation to fail.</P>
<P>However, something else takes place at this time. The compiler also copies the previously generated key from the symbol file  into the code file that is generated for the implementation part. </P>
<P>Likewise, when a program module is compiled, the syntax of program statements is checked against that defined in any modules being imported from, and the names and keys from all the definition parts of the library modules are collected and stored in the object code file from the program module. When the code files are all linked, the implementation modules are all read, and the keys are checked. If there are any differences, the system will refuse to link together the (presumed) incompatible modules, and the program will not link or run.</P>
<P>It must be understood that this checking of version compatibility is not implementation dependent, but is part of the very warp and woof of the notation. All Modula-2 systems must implement this library control behaviour, though the way in which they put it into practice may vary slightly.</P>
<P>The result is that compiling a program depends only on the definition modules for its success, but linking and running it requires that the implementation modules not only have been coded and compiled by this time, but that their keys agree with those of their corresponding definitions.</P>
<P><CENTER><IMG SRC="Figure/Figure_6.12.GIF" BORDER="1"></CENTER><!----></P>
<P>If it is later decided that there is a more efficient way to write the implementation of one of these portions of the package, this can be done without affecting either its definition, or any client programs.</P>
<P>On the other hand, any changes or recompiling of a definition module (with the possible exception of changes in comments in some implementations) requires that all clients depending on it also be recompiled before trying to link again. After all, changes at this level imply that there may now be syntax errors in both its corresponding implementation and in all client programs.</P>
<P>This behaviour of Modula-2 has two important implications for the designers of programs.</P>
<P>The first is that a program can be decomposed into a collection of modules, and the responsible team of programmers can agree collectively on the content of the various definition modules. These can be written and compiled so as to be available for all later stages of the project. Once this is done, the implementation modules and the program module can be assigned to various members of the team without any consultation on the details being necessary. This is because the definition modules contain the entire interface among the various parts of the final program, and are the only means by which they can obtain information from one another. Any changes one team proposes to a definition module have to be agreed to by all the teams, incorporated into the common interfaces, compiled and distributed to the teams before anyone uses them.</P>
<P>One consequence is that it does not matter what names each member of the team uses for variables and other local entities in the individual sections; there is no possibility for conflict among them. Modula-2 therefore completely eliminates side-effects caused by inadvertent re-use of entity names from one compilation unit to another. There is still a problem if a name is re-used within the same compilation module of course.</P>
<P>Furthermore, if someone finds a more efficient way of writing the implementation of a library module at a later date, this can be done, and the new version compiled, without having to re-compile the definition module or even any client program. (The keys all still agree.)  However, if the definition module is re-compiled for any reason (even if it has not actually been changed), a new key will be is placed in its symbol file, and the corresponding implementation part of the module and any program modules using it will become incompatible and will have to be re-compiled before the next attempt to link the code together.</P>
<P>Second, it is important to keep these dependencies in mind even in small projects, because ignoring them could cause major problems. These could arise from one of two situations:</P>
<P>1. The programmer makes changes to the number and type of parameters for some user library routine. Here, the enforcement of version compatibility is of great benefit, for the definition, implementation, and client program modules must all be rewritten and recompiled to reflect the changes. If it were possible to change the first without changing the other two, then the (presumably correct) definition part would interface to an incorrect or obsolete implementation part. This would undoubtedly cause a system crash at run time if it were allowed.</P>
<P>2. The programmer inadvertently recompiles a definition module without actually making any changes in it. This time, unnecessary problems are created, for what appears to be an identical definition part is in fact different, because of the new key associated with it. Since the implementation modules get their key from the previously compiled definition part of the module with the same name, the actual code is now inaccessible to the linker. It will compare the key from the program module, obtained from the previous version of the definition, with the key in the implementation obtained from the new version of the definition, and refuse to do the link because they are different. The system cannot, after all, "know" that you have made no changes<!--‹-->--the assumption is that the programmer must have had some reason for re-compiling the definition part.</P>
<P>If linking is done at run time, these problems will become evident the first time one tries to run a (perhaps previously successful) program that is a client of the incompatible module. If, on the other hand, the system does linking at a separate step and requires all code from library modules and elsewhere to be stored in a separate executable file (the most common method), the previously linked programs would still work, but a new attempt at linking would fail.</P>
<P>One can get into real trouble of the second type, because in some versions of Modula-2 the source codes for the system library definition modules are distributed on the disks along with the compiled versions. If one compiles any of these, access to the associated library module is cut off. Imagine not being able to use <I>STextIO</I> or any module that depends on it!  Since few vendors also include the source code for the implementation parts of library modules for recompiling, it would now be necessary to restore the original from a back-up (there is one, isn't there?) or place an embarrassing call to the vendor for a new disk.</P>
<P>Careful housekeeping and cautious file management will prevent such problems from arising. Original disks should be copied and filed in a safe place, and the text files for definition modules should be printed out for reference and then deleted from operating disks to prevent their recompilation by a user of the final package. Likewise, text files for a programmer's own library modules should be backed up on separate disks than those from which the compiled versions will eventually be run.</P>
<HR>
<CENTER><A HREF="../contents.html" TARGET="big_right">Contents</A>
</CENTER>
</BODY>
</HTML>