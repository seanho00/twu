<HTML>
<HEAD>
<TITLE>7.8 Random Numbers</TITLE>
<meta NAME="keywords" CONTENT="random, number, numbers, pseudo-random, pseudo, random, pre-determined, predetermined, linea, congruence, congruential, method, busyread, seed, cast, system, not, portable, pseudo-clock, clock">
<meta NAME="description" CONENT="Modula-2 shareware textbook by Rick Sutcliffe: Solving Real World Problems in Modula-2">
<META NAME="Author" content="Rick Sutcliffe">
<META NAME="Copyright" content="1983-2004 Rick Sutcliffe">
<STYLE TYPE="text/css"></STYLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../linkstyles.css" TITLE="Style">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

</HEAD>

<BODY BGCOLOR="#CCFFFF">
<SCRIPT LANGUAGE="JavaScript1.1">
<!--
function framesGO() {
// figures out the path to one directory above this document
// (where the MAIN index.html is) and puts it into theString:

theString=document.URL
theString=theString.substring(0,theString.lastIndexOf("/",theString.length - 14))
parent.window.location = theString + "/index.html?" + document.URL
}

// if this is the top frame, we'll create a link to activate some
// JavaScript to set up the frames around this document.  For more
// documentation, look at the comments in the source of the top frame
// (numberstr.html in this directory - not numberstr1.html).

if ((parent.frames.length) == 0)
{
document.write('<CENTER><A HREF=\"javascript:framesGO()\">Show outer (navigation) frames</A></CENTER><HR>')
}
else
{
if (navigator.appVersion.substring(0,1) == 3 && navigator.appName.lastIndexOf('Netscape') != -1)
{
parent.frames[0].location.replace('numberstr1.html')
// For some reason netscape 3 gets confused when it tries to run the cool JavaScript
// stuff in numberstr.html and continue to load this frame at the same time. >:-(
// So, we'll load the boring numberstr1.html instead.
}
else
{
parent.frames[0].location.replace('numberstr.html')
}
}
//-->
</SCRIPT>
<H2><B>7.8 Random Numbers</B></H2><P>
A number of applications in mathematics and computer science require collections of <I>random</I> numbers over some range.  For instance, one may wish to take a political poll by choosing telephone numbers at random.  A list of the possible exchanges could be made, and a household or business in one of them selected by generating a random number between 1 and 9999 for the last four digits of the call.</P>
<BLOCKQUOTE><I><A NAME="Random">A</A> <U>random number</U> in some range is chosen in such a way that every number is equally likely to be selected on each occasion.</I></BLOCKQUOTE>
<P>In most cases, including the one just mentioned, a sequence of random numbers, rather than a single number is required.  Not only ought each number to be random, but so should the order in which they occur in the sequence.  A great deal of work has been done on the properties of such collections of numbers and it is possible to obtain carefully worked out tables of such numbers that satisfy the most stringent criteria of randomness.</P>
<P>What is desired here is to fashion such a sequence using the computer.   One difficulty of doing this is the fact that is that once a given piece of code has been written for a computer, the same sequence of random numbers will be generated each time.  The numbers produced may well pass various tests of randomness, but they will not be truly <I>random</I> in at least one important sense<!--‹-->--they are predetermined.</P>
<BLOCKQUOTE><I><A NAME="Pseudo">Random</A> numbers generated by formula in a pre-determined sequence are called <U>pseudo-random</U> numbers.</I></BLOCKQUOTE>
<P>Some sequences of pseudo-random numbers are better than others.  Suppose one were working over the range [0 ..99] and used the sequence 0, 1, 2, 3, .. 99 or the sequence 0, 2, 4, 6, .. 98, 1, 3, 5, ...99.  In both cases, each number occurs only once (is equally represented), but in neither is any given number equally likely to be at any given position.  Moreover, if the second did not start over (mod 99), only half the numbers would occur at all. A random number generator must be able to do better than that.</P>
<P>As already noted, it is difficult to generate a sequence of truly random numbers.  However, the following function might do for many non-critical applications.  It does generate pseudo-random numbers<!--‹-->--and purists might argue that it does not do so very well, but it will serve for some purposes.</P>
<PRE>
<B>DEFINITION</B> <B>MODULE</B> Generator;
(* by R. Sutcliffe  revised 1993 04 06 *)

<B>PROCEDURE</B> Random ( ) : <B>REAL</B>;
(* Returns a random number 0 .. 1 *)

<B>END</B> Generator.

<B>IMPLEMENTATION</B> <B>MODULE</B> Generator;
(* by R. Sutcliffe  revised 1993 04 06 *)

<B>FROM</B> RealMath <B>IMPORT</B>
  exp, ln, pi;

<B>VAR</B>
  seed : <B>REAL</B>;
     (* global variable maintained between calls to Random *)

<B>PROCEDURE</B> Random ( ) : <B>REAL</B>;
(* Returns a random number 0 .. 1 *)

<B>VAR</B>
  temp : <B>REAL</B>;

<B>BEGIN</B>
  temp := seed + pi;   (* scramble up digits of seed *)
  temp := exp (5.0 * ln (temp));   (* scramble them some more *)
  seed := temp - <B>FLOAT</B> (<B>TRUNC</B> (temp));
  (* remove whole number part *)
  <B>RETURN</B> seed;
<B>END</B> Random;

<B>BEGIN</B>   (* initialize seed in body of module*)
  seed := 4.0;

<B>END</B> Generator.</PRE>
<P>Notice that in true Modula-2 style the value of <i>seed</i> is maintained, hidden away from the main program inside the library module Generator until the next time Random is called.  A brief test program follows:</P>
<PRE>
<B>MODULE</B> TestGenerator;
(* by R. Sutcliffe  revised 1993 04 06 *)

<B>IMPORT</B> STextIO;
<B>IMPORT</B> SRealIO;
<B>IMPORT</B> Generator;
<B>IMPORT</B> RedirStdIO; (* non-standard *)

<B>VAR</B>
  count : <B>CARDINAL</B>;

<B>BEGIN</B>
  RedirStdIO.OpenOutput;
  <B>FOR</B> count := 0 <B>TO</B> 19
    <B>DO</B>
      <B>IF</B> count <B>MOD</B> 4 = 0 (* write them four per line *)
        <B>THEN</B>
          STextIO.WriteLn;
        <B>END</B>;
      SRealIO.WriteFixed (Generator.Random (), 10,15);
    <B>END</B>; (* if *)
  RedirStdIO.CloseOutput;
<B>END</B> TestGenerator.</PRE>
<H3><B>Output:</B></H3>
<PRE>   0.0000000000   0.0198669434   0.8190307617   0.5805053711
   0.3963012695   0.2736206055   0.6108093262   0.9552612305
   0.1240234375   0.3860473633   0.2877807617   0.3228149414
   0.0510864258   0.7236328125   0.7287597656   0.4659423828
   0.0164794922   0.1307373047   0.2195129395   0.9540710449</PRE>
<P>These numbers <I>look</I> somewhat random, but the same sequence is obtained each time this program is run as things stand.  This library module could be improved with the addition of:</P>
<PRE>
  <B>PROCEDURE</B> Randomize (newSeed : <B>REAL</B>);
  (* reset the random number seed to a user supplied one *)</PRE>
<P>The most common technique for producing pseudo-random cardinal numbers, that satisfy most tests for randomness is called the <I>linear congruential</I> method.  It generates a new random number by multiplying the previous one by a constant <I>a</I>, adding one, and take the remainder modulo (MOD) a second constant m.  The result is a new random number that lies between zero and m - 1.  That is,</P>
<PRE>
  r := (r * a + 1) <B>MOD</B> m</PRE>
<P>Any initial value for <I>r</I> can be used as the seed to start things off and, as before, this seed will in fact determine the entire sequence. </P>
<P>Now, a close examination of this formula reveals a potentially serious problem, for if one assumes that <I>r</I> and <I>a</I> are of type CARDINAL, then unless both are kept very small, or the range for CARDINAL is large, the calculations are frequently going to overflow the data type, possibly on the very first attempt to obtain r * a.</P>
<P>Suppose one were generating random numbers in the range [0 .. 9999].  To prevent overflows, say when the previous value of <I>r</I> had been close to 9999, the value for <I>a</I> would have to be less than six, but this is not too practical.  Indeed, without going into the details here, it has been found that the best results are obtained if <I>a</I> has one digit less than <I>m</I>, ends with the digits <!--"-->&quot;21<!--"-->&quot; where <I>x</I> is even, and otherwise has no particular pattern in its digits.  What the calculation needs to do, then, is (r * a) MOD 10 000 but without any possible overflow when (r * a) is computed.  To accomplish this, break the number into two parts.  Since 10 000 is the square of 100, it is convenient to write</P>
<P>r = 100 <!--¥-->* r<sub>1</sub> + r<sub>0</sub></P>
<P>a = 100 <!--¥-->* 1 + 0</P>
<P>and express the multiplication as</P>
<P>r * a = (100 <!--¥-->* r<sub>1</sub> + r<sub>0</sub>) <!--¥-->* (100 <!--¥-->* 1 + 0)</P>
<P>	= (10 000 <!--¥-->* r<sub>1</sub> <!--¥-->* 1) + (100 <!--¥-->* (r<sub>1</sub> <!--¥-->* 0 + r<sub>0</sub> <!--¥-->* 1)) + (r<sub>0</sub> <!--¥-->* 0)</P>
<P>In this answer, one is now interested only in the third term and the rightmost two significant digits of the second term as the first one is already more than 10 000.</P>
<H3><B>Example:</B></H3>
<P>7245 <!--¥-->* 6175<BR>
= (100 <!--¥-->* 72 + 45) + (100 <!--¥-->* 61 + 75)<BR>
= 10000 (72 <!--¥-->* 61) + 100 (72 <!--¥-->* 75 + 45 <!--¥-->* 61) + 45 <!--¥-->* 75<BR>
= 10000 (4392) + 100 (8145) + 3375  (* break up the second term *)<BR>
= 10000 (4392 + 81) + 4500 + 3375<BR>
= 10000 (4473) + 7875</P>
<P>Had the last number also overflowed 10 000, one step would be added to <I>carry the one</I> to the first term.  Note, for later use, that this is a way to multiply two numbers in the range 0 .. 9999 and keep track of <I>all</I> the digits in the answer<!--‹-->--in this case, store 7875 in one CARDINAL, and 4473 in another. (9999<sup>2</sup> is too large to fit into the cardinal type in many implementations.  Even if not, a similar argument could be applied to 9999999, if that were the largest such number representable in the cardinal type.)</P>
<P>Once the whole process in finished in this situation, however, the focus is on only in the rightmost four digits (7875).  Putting these observations together in a problem refinement and writing the code yields:</P>
<H3><B>Problem:</B></H3>
<P>Write a procedure to multiply two numbers in the range [0 .. 9999] and retain only the last four digits.</P>
<H3><B>Solution:</B></H3>
<P>Break the numbers into two parts of the form 100 <!--¥-->* 1 + 0.</P>
<P>  for a number n<BR>
    1 = n DIV 100<BR>
    0 = n MOD 100</P>
<P>Multiply these as binomials as shown above.</P>
<P>  The resulting terms are:<BR>
    1 = r<sub>1</sub> <!--¥-->* 1 (understood to be times 10000)<BR>
    2 = r<sub>1</sub> <!--¥-->* 0 + r<sub>0</sub> <!--¥-->* 1 (times 100)<BR>
    3 = r<sub>0</sub> <!--¥-->* 0</P>
<P>Add together the parts affecting the rightmost digits.</P>
<P>  answer =100 (2 MOD 100) + 3</P>
<P>Discard any portion over 10000.</P>
<P>  answer = answer MOD 10000</P>
<P>Here is the code for this procedure:</P>
<PRE>
<B>PROCEDURE</B> Multiply (mplier, mcand : <B>CARDINAL</B>) : <B>CARDINAL</B>;
  (* Pre: mplier and mcand are both in the range [0 .. 9999]
  Post: Returns (mplier * mcand) mod 10000 *)

<B>TYPE</B>
  parts = <B>ARRAY</B> [0 .. 1] <B>OF</B> <B>CARDINAL</B>;

<B>VAR</B>
  x, y : parts;

<B>BEGIN</B>
  x[1] := mplier <B>DIV</B> 100;   (* break numbers into two parts *)
  x[0] := mplier <B>MOD</B> 100;
  y[1] := mcand <B>DIV</B> 100;
  y[0] := mcand <B>MOD</B> 100;
  <B>RETURN</B>
    (((x[1] * y[0] + x[0] * y[1]) <B>MOD</B> 100) * 100
    + x[0] * y[0]) <B>MOD</B> 10000;

<B>END</B> Multiply;</PRE>
<P>With that, it is possible to re-write the procedure Random for cardinals.</P>

<PRE><B>PROCEDURE</B> Random ( ) : <B>CARDINAL</B>;

<B>CONST</B>
  a = 73421;

<B>BEGIN</B>
  seed := (Multiply (seed, a) + 1) <B>MOD</B> 10000;
  <B>RETURN</B> seed;
<B>END</B> Random;</PRE>
<P>Finally, there are several ways to initialize r  for the first time in the body of the library module containing this procedure.  It could be read in from the keyboard, or an attempt could be made to generate it in some truly <I>random</I> fashion.  So the body could look like this:</P>
<PRE>
<B>BEGIN</B>
  WriteString (<!--"-->&quot; What is the random number seed<!--"-->&quot;);
  ReadCard (r);
  WriteLn;
<B>END</B> Randomizer;</PRE>
<P>Some versions of Modula-2 provide a procedure <I>BusyRead</I>.  This procedure polls the keyboard for a character and immediately returns either CHR(0) if nothing has yet been typed, or the character typed if one was.  So, perhaps randomizing the seed could be done like this:</P>
<PRE>
<B>PROCEDURE</B> RandomizeK ();

<B>VAR</B>
  ch : <B>CHAR</B>;

<B>BEGIN</B>
  STextIO.WriteString (<!--"-->&quot; Randomizing the seed number <!--"-->&quot;);
  STextIO.WriteLn;
  STextIO.WriteString (<!--"-->&quot; Please press a key <!--"-->&quot;);
  <B>REPEAT</B>
    BusyRead (ch);
    seed := Random ();
  <B>UNTIL</B> ch # <B>CHR</B> (0)
<B>END</B> RandomizeK;</PRE>
<P>The idea here is that <I>seed</I> begins with whatever number happens to be in the memory at the time the procedure is entered.  This depends on the sequence of events since start up of the computer.  <I>Random</I> is called repeatedly until the user presses a key.  Since everyone has a different reaction time and this loop would execute many times before the keypress, the value of the initial <I>seed</I> and thus of the whole sequence would be more genuinely random.</P>
<P>Still another method is available to those who have an intimate knowledge of the workings of the particular hardware on which their randomizer is running.  Many systems change a particular memory location at regular (or irregular) intervals, and if a method of accessing such a location is known, its contents may be interpreted as a cardinal, and used for the seed.</P>
<P><B>NOTE</B>:	Forcible re-interpretation of the data in some memory location, initially named by a variable of some other type is done using <i>newName := CAST (newTypeName, variableName);</i> where CAST is imported from the module SYSTEM.  Use of any procedures or types in the module SYSTEM implies that the code is not portable to some other computing system.</P>
<P>A popular choice is a memory location representing the value held for a clock of some kind.  The latter may be a real-time clock, whose contents are a representation of the time and (possibly) the date.  It could be a pseudo-clock, sometimes called a <I>tick count</I>, which is a location automatically incremented by the operating system as part of various other tasks it performs.  The contents of the <I>tick count</I> location, where applicable, are predictable for a given time and sequence of events after system start up, but as both of these may vary considerably before the randomizing function is called, the results may be quite satisfactory.</P>
<P>Note also that all references to 10000 and 100 in the above discussion could be replaced by some other numbers, say <I>m</I> and <I>n</I> with n<sup>2</sup> = m as long as <I>m</I> is less than half of the largest possible CARDINAL.  A suitable expansion is possible if the nonstandard LONGCARD is available or the type CARDINAL has a sufficiently large maximum value.  It might be best to write the algorithm with references to 10 000 and 100 replaced by constants so that these can easily be changed.</P>
<P>It is also worth noting that the last digits of a pseudo-random number sequence cycle through a regular pattern (test this!) and that sequences of random numbers over some specified range that are produced from some generic generator should therefore use the first digits for the numbers in the sequence.</P>
<P>For this reason, most generators return a REAL between 0 and 1 (say, by dividing by 10 000 in this case).  Given this assumption, a program would then acquire a random number from such a generator<!--‹-->--say in the range [0 .. j - 1] by executing the statement:</P>
<PRE>
num := <B>TRUNC</B> (j * RealRandom () )</PRE>
<P>The procedure RealRandom might then be:</P>
<PRE>
<B>PROCEDURE</B> RealRandom () : <B>REAL</B>;

<B>CONST</B>
  m = 10 000;  (* easy to change this way *)

<B>BEGIN</B>
  seed := (Multiply (seed, a) + 1) <B>MOD</B> m;
  <B>RETURN</B> <B>FLOAT</B> (seed) / <B>FLOAT</B> (m)
<B>END</B> RealRandom;</PRE>
<P>Here is a library module based on some of the ideas in this section.  The implementation was written specifically for the Macintosh computer and uses a system utility to access the memory location containing the tick count, so the code is not portable to other systems.</P>
<PRE>
<A NAME="Randoms"></A><B>DEFINITION</B> <B>MODULE</B> Randoms;

(* Written by Mark Harder
revised by R. Sutcliffe 1993 04 15 *)

(* Rnd and Random use the linear congruential generator method *)

<B>PROCEDURE</B> Randomize ( );
  (* Pre: none
  Post: Sets the seed for random Rnd based on tick count. *)
	
<B>PROCEDURE</B> SetSeed (seed : <B>CARDINAL</B>);
  (* Pre: none
  Post: Sets the seed to specified seed value. *)

<B>PROCEDURE</B> Rnd ( ) : <B>CARDINAL</B>;
  (* Pre: none
  Post: Returns a pseudorandom number of the range of cardinal *)

<B>PROCEDURE</B> RndInRange (low, high : <B>CARDINAL</B>) : <B>CARDINAL</B>;
  (* Pre: none
  Post: Returns a pseudorandom cardinal number in the range low .. high *)

<B>PROCEDURE</B> Random ( ) : <B>REAL</B>;
  (* Pre: none
  Post: Returns a pseudorandom real number in the range of [0 .. 1) *)

<B>END</B> Randoms.

<B>IMPLEMENTATION</B> <B>MODULE</B> Randoms;

(* Written by Mark Harder
for the Macintosh computer (system dependent)
revised by R. Sutcliffe 1993 04 15 *)

<B>FROM</B> SYSTEM <B>IMPORT</B>
  CAST; (* means this is non-portable *)
<B>FROM</B> Events <B>IMPORT</B> (* Mac system only *)
  TickCount;
<B>FROM</B> RealMath <B>IMPORT</B>
  ln, sqrt, pi;

<B>CONST</B>
  a = 94621;  (* fits pattern of digits and is prime *)
  maxcard = <B>MAX</B> (<B>CARDINAL</B>);
  cardmodulus = <B>FLOAT</B> (maxcard) + 1.0;
    (* can't express cardinal modulus in cardinal *)

<B>VAR</B>
  gSeed : <B>CARDINAL</B>;

<A NAME="Multiply"></A><B>PROCEDURE</B> Multiply (mplier, mcand : <B>CARDINAL</B>) : <B>CARDINAL</B>;
  (* Returns (x * y) mod maxcard *)

<B>TYPE</B>
  parts = <B>ARRAY</B> [0 .. 1] <B>OF</B> <B>CARDINAL</B>;

<B>VAR</B>
  x, y : parts;
  rtmxcard : <B>CARDINAL</B>;
  temp : <B>REAL</B>;

<B>BEGIN</B>
  rtmxcard := <B>TRUNC</B> (sqrt (cardmodulus) + 0.01);
    (* but can its square root *)
  x[1] := mplier <B>DIV</B> rtmxcard;(* break numbers into two parts *)
  x[0] := mplier <B>MOD</B> rtmxcard;
  y[1] := mcand <B>DIV</B> rtmxcard;
  y[0] := mcand <B>MOD</B> rtmxcard;
  temp := <B>FLOAT</B> (((x[1] * y[0] + x[0] * y[1])
           <B>MOD</B> rtmxcard) * rtmxcard + x[0] * y[0]);
  <B>IF</B> temp <!-->&gt; cardmodulus
    <B>THEN</B>
      temp := temp - cardmodulus; (* will only have to do once *)
    <B>END</B>;
  <B>RETURN</B> <B>TRUNC</B> (temp);
<B>END</B> Multiply;

<B>PROCEDURE</B> Randomize ();

(* You have to know this cast is appropriate. *)

<B>BEGIN</B>
  gSeed := CAST (<B>CARDINAL</B>, TickCount());
<B>END</B> Randomize;
  
<B>PROCEDURE</B> SetSeed (seed : <B>CARDINAL</B>);
 
<B>BEGIN</B>
  gSeed := seed;
<B>END</B> SetSeed;

<B>PROCEDURE</B> Rnd () : <B>CARDINAL</B>;
(* pseudorandom numbers in the range of cardinal *)
<B>BEGIN</B>
   (* linear congruential generator. *)
  gSeed := Multiply (a, gSeed);
  <B>IF</B> gSeed <!--<-->&lt; maxcard (* now do the add 1 and mod maxcard part *)
    <B>THEN</B>
      <B>INC</B> (gSeed);
    <B>ELSE</B>
      gSeed := 0;
    <B>END</B>;
  <B>RETURN</B> (gSeed)
<B>END</B> Rnd;

<A NAME="RndInRange"></A><B>PROCEDURE</B> RndInRange (low, high : <B>CARDINAL</B>) : <B>CARDINAL</B>;

<B>VAR</B>
  range, result : <B>CARDINAL</B>;
  
<B>BEGIN</B>
  range := high - low;
  result := (Rnd () <B>MOD</B> (range + 1) ); (* in range 0 .. range *)
  <B>INC</B> (result, low);  (* adjust range *)
  <B>RETURN</B> (result);
<B>END</B> RndInRange;

<B>PROCEDURE</B> Random () : <B>REAL</B>;

<B>VAR</B>
  temp : <B>REAL</B>;

<B>BEGIN</B>
  <B>RETURN</B> <B>FLOAT</B> (Rnd ())/ <B>FLOAT</B> (cardmodulus);
<B>END</B> Random;

<B>BEGIN</B>
   Randomize ();
<B>END</B> Randoms.</PRE>
<P>Note the changes to the multiplication procedure to make it operate over the entire range of cardinals.  There are other ways of doing this, including converting both numbers to reals, performing a real multiplication, stripping the amount over <I>maxcard</I> and converting back to a cardinal.  You will be asked to produce this and some other refinements of this material in the exercises at the end of this chapter.  With the proper imports, a client program could itself employ the keyboard response method of randomizing the seed by changing the line in the procedure <I>RandomizeK</I> earlier in this section from</P>
<PRE>
  seed := Random ();</PRE>
<P>to</P>
<PRE>
  Randoms.Randomize ();</PRE>
<P>It is also worth observing at this point that some versions of Modula-2 provide random number generator functions provided in a library module.  As these are not in any sense standard items, the names, syntax, and location of such items will vary from one implementation to another and they are likely to be machine dependent.  Check the documentation for details.</P>
<HR>
<CENTER><A HREF="../contents.html" TARGET="big_right">Contents</A>
</CENTER>
</BODY>
</HTML>