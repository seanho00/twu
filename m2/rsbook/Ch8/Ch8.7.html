<HTML>
<HEAD>
<TITLE>8.7 Binary I/O</TITLE></TITLE>
<meta NAME="keywords" CONTENT="binary, i/o, input, output, raw, readword, wordread, readbytes, readbyte, writebyte, writebytes, writeword, buffer, temporary, storage, storages, rawio, srawio, iochan, system, text">
<meta NAME="description" CONENT="Modula-2 shareware textbook by Rick Sutcliffe: Data Storage and Issues">
<META NAME="Author" content="Rick Sutcliffe">
<META NAME="Copyright" content="1983-2004 Rick Sutcliffe">
<STYLE TYPE="text/css"></STYLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../linkstyles.css" TITLE="Style">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

</HEAD>

<BODY BGCOLOR="#CCFFFF">
<SCRIPT LANGUAGE="JavaScript1.1">
<!--
function framesGO() {
// figures out the path to one directory above this document
// (where the MAIN index.html is) and puts it into theString:

theString=document.URL
theString=theString.substring(0,theString.lastIndexOf("/",theString.length - 14))
parent.window.location = theString + "/index.html?" + document.URL
}

// if this is the top frame, we'll create a link to activate some
// JavaScript to set up the frames around this document.  For more
// documentation, look at the comments in the source of the top frame
// (numberstr.html in this directory - not numberstr1.html).

if ((parent.frames.length) == 0)
{
document.write('<CENTER><A HREF=\"javascript:framesGO()\">Show outer (navigation) frames</A></CENTER><HR>')
}
else
{
if (navigator.appVersion.substring(0,1) == 3 && navigator.appName.lastIndexOf('Netscape') != -1)
{
parent.frames[0].location.replace('numberstr1.html')
// For some reason netscape 3 gets confused when it tries to run the cool JavaScript
// stuff in numberstr.html and continue to load this frame at the same time. >:-(
// So, we'll load the boring numberstr1.html instead.
}
else
{
parent.frames[0].location.replace('numberstr.html')
}
}
//-->
</SCRIPT><H2><B>8.7 Binary I/O</B></H2>
<P>The text files used thus far are very versatile, for they are stored in much the same form by all applications in all environments.  Thus it is possible for the text editor to be used to create a data file for program use.  Likewise, the text output files generated by programs can easily be read by any other program with text capability.</P>
<P>There are times, however, when it is more desirable to input or output data in a binary form.  The channels employed are still streams, but not of text.  Rather, they are streams of raw data copied directly from the computer's memory.</P>
<P>Typical facilities for raw I/O may be found in non-standard versions residing directly in the Filer/Files/FileSystem module, usually in the form of the following procedures:</P>
<PRE>
(* typical non-ISO procedures *)
<B>PROCEDURE</B> ReadWord (file : File; <B>VAR</B> input : WORD);
 (* Reads the next word from the file 'file' and stores it in 'input'. *)

<B>PROCEDURE</B> ReadBytes (file : File; buffer : ADDRESS; <B>VAR</B> length : <B>CARDINAL</B>);
  (* Reads 'length' bytes from the file 'file' and stores them at 'buffer'. Actual number of bytes read returned in length  If the buffer is too small, data will be overwritten. This is a low level procedure -- don't use unless you know what you are doing *)

<B>PROCEDURE</B> WriteByte (file : File; output : BYTE);
  (* Writes the byte in 'output' to the file 'file'. *)

<B>PROCEDURE</B> WriteWord (file : File; output : WORD);
 (* Writes the word in 'output' to the file 'file'. *)

<B>PROCEDURE</B> WriteBytes (file : File; buffer : ADDRESS; <B>VAR</B> length : <B>CARDINAL</B>);
  (* Writes the 'length' bytes starting at 'buffer' to the file 'file'. Actual number of bytes read returned in length. If the buffer is too small, undefined bytes will be written. So don't use this unless you know what you are doing *) </PRE>
<P>As it will be used below, it is useful to define the term <I>buffer</I>.</P>
<BLOCKQUOTE><I><A NAME="Buffer">A</A> <U>buffer</U> is a temporary storage area that is used to store information being transmitted to or from an external location (including a physical file).</I></BLOCKQUOTE>
<P>In the ISO suite of I/O library modules, on the other hand, channels can be opened in the same way as previously described using <I>SeqFile</I> or <I>StreamFile</I> and then I/O operations handled using facilities of <I>RawIO</I>.  There is also an <I>SRawIO</I>, but unless the user is aware of the meaning of sending raw binary data to the standard output, there is little point in employing its routines.  Here is the definition of <I>RawIO</I>.</P>
<PRE>
<B>DEFINITION</B> <B>MODULE</B> RawIO; (* from ISO suite *)

  (* Reading and writing data over specified channels using raw operations, that is, with no conversion or interpretation. The read result is of the type IOConsts.ReadResults. *)
 
<B>IMPORT</B> IOChan, SYSTEM;
 
<B>PROCEDURE</B> Read (cid: IOChan.ChanId; <B>VAR</B> to: <B>ARRAY</B> <B>OF</B> SYSTEM.LOC);
  (* Reads storage units from cid, and assigns them to successive components of to. The read result is set to the value allRight, wrongFormat, or endOfInput. *)
 
<B>PROCEDURE</B> Write (cid: IOChan.ChanId; from: <B>ARRAY</B> <B>OF</B> SYSTEM.LOC);
  (* Writes storage units to cid from successive components of from. *)
 
<B>END</B> RawIO.</PRE>
<P>For instance, the integers collected in the first example <I>GetNStash</I> of section 8.5.1 could have been stored to a file in raw form rather than in text form by replacing the line</P>
<PRE>
WholeIO.WriteInt (outfile, number, 0);</PRE>
<P>with the line</P>
<PRE>
RawIO.Write (outfile, number);</PRE>
<P>as the variable number of the type INTEGER (and all other variables, of whatever type) is compatible with the parameter ARRAY OF SYSTEM.LOC.</P>
<P>Then, in the module <I>ReadNAdd</I> that followed the line</P>
<PRE>
ReadInt (infile, number);</PRE>
<P>would be replaced with the line</P>
<PRE>
Read (infile, number);</PRE>
<P>where <I>Read</I> had been imported from <I>RawIO</I>.</P>
<P>In both cases, however, the file should be opened with the parameter <I>raw</I> as shown below:</P>
<PRE>
Open (outfile, <!--"-->&quot;numbers<!--"-->&quot;, write+raw, res);</PRE>
<P>and</P>
<PRE>
Open (infile, <!--"-->&quot;numbers<!--"-->&quot;, read+raw, res);</PRE>
<P>When using either <I>StreamFile</I> or <I>SeqFile</I> without the <I>raw</I> flag, a flag of <I>text</I> is implied.  Both <I>raw</I> and <I>text</I> forms of I/O could be done with a channel if both flags were given, but that combination is rather unlikely.  The disadvantage to using raw I/O is that the resulting files would not be text files, but images of the computer's memory.  Thus, they could not be read by a text editor.  On the other hand, the memory storage of an integer is likely to occupy only two or four locations, whereas one location is required for each character when it is written as text.   The raw file is much smaller in size, and can be written to and read from much more quickly than the corresponding text file.  As is often the case, speed is gained by taking a low level view, but the benefit is at the expense of convenience.</P>
<P>To illustrate some of these ideas with a fuller example, the <I>FileCopy</I> module is here rewritten to employ the ISO modules rather than the low-level <I>Filer</I> as in <A HREF="Ch8.6.html#8.6.3">section 8.6.3</A>.  Observe that although the file being copied happens to be in fact a text file, this is not used by the program, and its code could copy any file.  In addition, this program makes use of its own internal buffer to store the file.</P>
<PRE>
<B>MODULE</B> FileCopyRaw;

(* Written by R.J. Sutcliffe *)
(* to illustrate the use of ISO module RawIO *)
(* last revision 1994 02 10 *)
(* This module reads a file called <!--"-->&quot;numbers<!--"-->&quot; and copies it to <!--"-->&quot;numbers.bak<!--"-->&quot;. *)

<B>FROM</B> StreamFile <B>IMPORT</B>
  ChanId, Open, read, write, old, raw, Close, OpenResults;
<B>FROM</B> IOResult <B>IMPORT</B>
  ReadResult, ReadResults;
<B>IMPORT</B> RawIO; 
<B>FROM</B> SYSTEM <B>IMPORT</B>
  LOC;

<B>CONST</B>
  bMaxIndex = 20;
<B>TYPE</B>
  Buffer = <B>ARRAY</B> [0 .. bMaxIndex] <B>OF</B> LOC;
<B>VAR</B>
  infile, outfile : ChanId;
  ch : <B>CHAR</B>;
  buffer: Buffer;
  res : OpenResults;
  countR, countW : <B>CARDINAL</B>;

<B>BEGIN</B>
  Open (infile, <!--"-->&quot;numbers<!--"-->&quot;, read+raw, res);
  <B>IF</B> res = opened
    <B>THEN</B>
      Open (outfile, <!--"-->&quot;numbers.bak<!--"-->&quot;, write+raw+old, res);
      (* allow overwrite *)
      <B>IF</B> res = opened
        <B>THEN</B>
          <B>REPEAT</B>
            countR := 0;
            <B>REPEAT</B> (* fill the buffer as much as possible *)
              RawIO.Read (infile, buffer [countR]);
              <B>INC</B> (countR);
            <B>UNTIL</B> (ReadResult (infile) = endOfInput) <B>OR</B> (countR <!-->&gt; bMaxIndex);

            <B>IF</B> ReadResult (infile) = endOfInput
              <B>THEN</B>  (* last one read should not be counted *)
                <B>DEC</B> (countR)
              <B>END</B>;
 
            countW := 0;
            <B>WHILE</B> countR <!-->&gt; 0 (* write stuff read in last loop *)
              <B>DO</B>
                RawIO.Write (outfile, buffer [countW]);
                <B>INC</B> (countW);
                <B>DEC</B> (countR);
             <B>END</B>;
          <B>UNTIL</B> (ReadResult (infile) = endOfInput)
        <B>END</B>;
      <B>END</B>;
  Close (infile);
  Close (outfile);
<B>END</B> FileCopyRaw.</PRE>
<HR>
<CENTER><A HREF="../contents.html" TARGET="big_right">Contents</A>
</CENTER>
</BODY>
</HTML>