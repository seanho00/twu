<HTML><HEAD><TITLE>Appendix 9--ISO Mathematics Library Modules</TITLE><STYLE TYPE="text/css"></STYLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../linkstyles.css" TITLE="Style">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

</HEAD>
<BODY BGCOLOR="#CCFFFF">
<SCRIPT LANGUAGE="JavaScript1.1">
<!--
function framesGO() {
// figures out the path to one directory above this document
// (where the MAIN index.html is) and puts it into theString:

theString=document.URL
theString=theString.substring(0,theString.lastIndexOf("/",theString.length - 14))
parent.window.location = theString + "/index.html?" + document.URL
}

// if this is the top frame, we'll create a link to activate some
// JavaScript to set up the frames around this document.  For more
// documentation, look at the comments in the source of the top frame
// (numberstr.html in this directory - not numberstr1.html).

if ((parent.frames.length) == 0)
{
document.write('<CENTER><A HREF=\"javascript:framesGO()\">Show outer (navigation) frames</A></CENTER><HR>')
}
else
{
if (navigator.appVersion.substring(0,1) == 3 && navigator.appName.lastIndexOf('Netscape') != -1)
{
parent.frames[0].location.replace('numberstr1.html')
// For some reason netscape 3 gets confused when it tries to run the cool JavaScript
// stuff in numberstr.html and continue to load this frame at the same time. >:-(
// So, we'll load the boring numberstr1.html instead.
}
else
{
parent.frames[0].location.replace('numberstr.html')
}
}
//-->
</SCRIPT>
<H2><B>Appendix 9<!--</B>‹<B>-->--ISO Mathematics Library Modules</B></H2>

<P><!--revised 1995 06 10--></P>
<H3><B><A NAME="A9.1">A9.1</A> RealMath</B></H3>
<PRE>
<B>DEFINITION</B> <B>MODULE</B> RealMath;

  (* Mathematical functions for the type REAL *)

<B>CONST</B>
  pi   = 3.1415926535897932384626433832795028841972;
  exp1 = 2.7182818284590452353602874713526624977572;

<B>PROCEDURE</B> sqrt (x: <B>REAL</B>): <B>REAL</B>;
  (* Returns the positive square root of x *)

<B>PROCEDURE</B> exp (x: <B>REAL</B>): <B>REAL</B>;
  (* Returns the exponential of x *)

<B>PROCEDURE</B> ln (x: <B>REAL</B>): <B>REAL</B>;
  (* Returns the natural logarithm of x *)

  (* The angle in all trigonometric functions is measured in radians *)

<B>PROCEDURE</B> sin (x: <B>REAL</B>): <B>REAL</B>;
  (* Returns the sine of x *)

<B>PROCEDURE</B> cos (x: <B>REAL</B>): <B>REAL</B>;
  (* Returns the cosine of x *)

<B>PROCEDURE</B> tan (x: <B>REAL</B>): <B>REAL</B>;
  (* Returns the tangent of x *)

<B>PROCEDURE</B> arcsin (x: <B>REAL</B>): <B>REAL</B>;
  (* Returns the arcsine of x *)

<B>PROCEDURE</B> arccos (x: <B>REAL</B>): <B>REAL</B>;
  (* Returns the arccosine of x *)

<B>PROCEDURE</B> arctan (x: <B>REAL</B>): <B>REAL</B>;
  (* Returns the arctangent of x *)

<B>PROCEDURE</B> power (base, exponent: <B>REAL</B>): <B>REAL</B>;
  (* Returns the value of the number base raised to the power exponent *)

<B>PROCEDURE</B> round (x: <B>REAL</B>): <B>INTEGER</B>;
  (* Returns the value of x rounded to the nearest integer *)

<B>PROCEDURE</B> IsRMathException (): <B>BOOLEAN</B>;
  (* Returns TRUE if the current coroutine is in the exceptional execution state because of the raising of an exception in a routine from this module; otherwise returns FALSE.  *)

<B>END</B> RealMath.</PRE>
<H3><B><A NAME="A9.2">A9.2</A> LongMath</B></H3>
<PRE>
<B>DEFINITION</B> <B>MODULE</B> LongMath;
 
  (* Mathematical functions for the type LONGREAL *)

<B>CONST</B>
  pi   = 3.1415926535897932384626433832795028841972; 
  exp1 = 2.7182818284590452353602874713526624977572;  

<B>PROCEDURE</B> sqrt (x: <B>LONGREAL</B>): <B>LONGREAL</B>;
  (* Returns the positive square root of x *)

<B>PROCEDURE</B> exp (x: <B>LONGREAL</B>): <B>LONGREAL</B>;
  (* Returns the exponential of x *)

<B>PROCEDURE</B> ln (x: <B>LONGREAL</B>): <B>LONGREAL</B>;
  (* Returns the natural logarithm of x *)

  (* The angle in all trigonometric functions is measured in radians *)

<B>PROCEDURE</B> sin (x: <B>LONGREAL</B>): <B>LONGREAL</B>;
  (* Returns the sine of x *)

<B>PROCEDURE</B> cos (x: <B>LONGREAL</B>): <B>LONGREAL</B>;
  (* Returns the cosine of x *)

<B>PROCEDURE</B> tan (x: <B>LONGREAL</B>): <B>LONGREAL</B>;
  (* Returns the tangent of x *)

<B>PROCEDURE</B> arcsin (x: <B>LONGREAL</B>): <B>LONGREAL</B>;
  (* Returns the arcsine of x *)

<B>PROCEDURE</B> arccos (x: <B>LONGREAL</B>): <B>LONGREAL</B>;
  (* Returns the arccosine of x *)

<B>PROCEDURE</B> arctan (x: <B>LONGREAL</B>): <B>LONGREAL</B>;
  (* Returns the arctangent of x *)

<B>PROCEDURE</B> power (base, exponent: <B>LONGREAL</B>): <B>LONGREAL</B>;
  (* Returns the value of the number base raised to the power exponent *)

<B>PROCEDURE</B> round (x: <B>LONGREAL</B>): <B>INTEGER</B>;
  (* Returns the value of x rounded to the nearest integer *)

<B>PROCEDURE</B> IsRMathException (): <B>BOOLEAN</B>;
  (* Returns TRUE if the current coroutine is in the exceptional execution state because of the raising of an exception in a routine from this module; otherwise returns FALSE.  *)

<B>END</B> LongMath.</PRE>
<H3><B><A NAME="A9.3">A9.3</A> ComplexMath</B></H3>
<PRE>
<B>DEFINITION</B> <B>MODULE</B> ComplexMath;

(* =========================================
    Original COMPLEX specification and
           design of ComplexMath 
    Copyright © 1990-1991 by R. Sutcliffe
    Assigned to the BSI for standards work

===========================================*)

  (* Mathematical functions for the type COMPLEX *)
 
<B>CONST</B>
  i =    <B>CMPLX</B> (0.0, 1.0);
  one =  <B>CMPLX</B> (1.0, 0.0);
  zero = <B>CMPLX</B> (0.0, 0.0);

<B>PROCEDURE</B> abs (z: <B>COMPLEX</B>): <B>REAL</B>;
  (* Returns the length of z *)

<B>PROCEDURE</B> arg (z: <B>COMPLEX</B>): <B>REAL</B>;
  (* Returns the angle that z subtends to the positive real axis *)
 
<B>PROCEDURE</B> conj (z: <B>COMPLEX</B>): <B>COMPLEX</B>;
  (* Returns the complex conjugate of z *)
 
<B>PROCEDURE</B> power (base: <B>COMPLEX</B>; exponent: <B>REAL</B>): <B>COMPLEX</B>;
  (* Returns the value of the number base raised to the power exponent *)

<B>PROCEDURE</B> sqrt (z: <B>COMPLEX</B>): <B>COMPLEX</B>;
  (* Returns the principal square root of z *)

<B>PROCEDURE</B> exp (z: <B>COMPLEX</B>): <B>COMPLEX</B>;
  (* Returns the complex exponential of z *)

<B>PROCEDURE</B> ln (z: <B>COMPLEX</B>): <B>COMPLEX</B>;
  (* Returns the principal value of the natural logarithm of z *)

<B>PROCEDURE</B> sin (z: <B>COMPLEX</B>): <B>COMPLEX</B>;
  (* Returns the sine of z *)

<B>PROCEDURE</B> cos (z: <B>COMPLEX</B>): <B>COMPLEX</B>;
  (* Returns the cosine of z *)

<B>PROCEDURE</B> tan (z: <B>COMPLEX</B>): <B>COMPLEX</B>;
  (* Returns the tangent of z *)

<B>PROCEDURE</B> arcsin (z: <B>COMPLEX</B>): <B>COMPLEX</B>;
  (* Returns the arcsine of z *)

<B>PROCEDURE</B> arccos (z: <B>COMPLEX</B>): <B>COMPLEX</B>;
  (* Returns the arccosine of z *)

<B>PROCEDURE</B> arctan (z: <B>COMPLEX</B>): <B>COMPLEX</B>;
  (* Returns the arctangent of z *)

<B>PROCEDURE</B> polarToComplex (abs, arg: <B>REAL</B>): <B>COMPLEX</B>;
  (* Returns the complex number with the specified polar coordinates *)

<B>PROCEDURE</B> scalarMult (scalar: <B>REAL</B>; z: <B>COMPLEX</B>): <B>COMPLEX</B>;
  (* Returns the scalar product of scalar with z *)

<B>PROCEDURE</B> IsCMathException (): <B>BOOLEAN</B>;
  (* Returns TRUE if the current coroutine is in the exceptional execution state  because of the raising of an exception in a routine from this module; otherwise returns FALSE. *)

<B>END</B> ComplexMath.</PRE>
<H3><B><A NAME="A9.4">A9.4</A> LongComplexMath</B></H3>
<PRE>
<B>DEFINITION</B> <B>MODULE</B> LongComplexMath;

(* =========================================
    Original COMPLEX specification and
           design of ComplexMath 
    Copyright © 1990-1991 by R. Sutcliffe
    Assigned to the BSI for standards work
===========================================*)

  (* Mathematical functions for the type LONGCOMPLEX *)
 
<B>CONST</B>
  i =    <B>CMPLX</B> (0.0, 1.0);
  one =  <B>CMPLX</B> (1.0, 0.0);
  zero = <B>CMPLX</B> (0.0, 0.0);

<B>PROCEDURE</B> abs (z: <B>LONGCOMPLEX</B>): <B>LONGREAL</B>;
  (* Returns the length of z *)

<B>PROCEDURE</B> arg (z: <B>LONGCOMPLEX</B>): <B>LONGREAL</B>;
  (* Returns the angle that z subtends to the positive real axis *)
 
<B>PROCEDURE</B> conj (z: <B>LONGCOMPLEX</B>): <B>LONGCOMPLEX</B>;
  (* Returns the complex conjugate of z *)
 
<B>PROCEDURE</B> power (base: <B>LONGCOMPLEX</B>; exponent: <B>LONGREAL</B>): <B>LONGCOMPLEX</B>;
  (* Returns the value of the number base raised to the power exponent *)

<B>PROCEDURE</B> sqrt (z: <B>LONGCOMPLEX</B>): <B>LONGCOMPLEX</B>;
  (* Returns the principal square root of z *)

<B>PROCEDURE</B> exp (z: <B>LONGCOMPLEX</B>): <B>LONGCOMPLEX</B>;
  (* Returns the complex exponential of z *)

<B>PROCEDURE</B> ln (z: <B>LONGCOMPLEX</B>): <B>LONGCOMPLEX</B>;
  (* Returns the principal value of the natural logarithm of z *)

<B>PROCEDURE</B> sin (z: <B>LONGCOMPLEX</B>): <B>LONGCOMPLEX</B>;
  (* Returns the sine of z *)

<B>PROCEDURE</B> cos (z: <B>LONGCOMPLEX</B>): <B>LONGCOMPLEX</B>;
  (* Returns the cosine of z *)

<B>PROCEDURE</B> tan (z: <B>LONGCOMPLEX</B>): <B>LONGCOMPLEX</B>;
  (* Returns the tangent of z *)

<B>PROCEDURE</B> arcsin (z: <B>LONGCOMPLEX</B>): <B>LONGCOMPLEX</B>;
  (* Returns the arcsine of z *)

<B>PROCEDURE</B> arccos (z: <B>LONGCOMPLEX</B>): <B>LONGCOMPLEX</B>;
  (* Returns the arccosine of z *)

<B>PROCEDURE</B> arctan (z: <B>LONGCOMPLEX</B>): <B>LONGCOMPLEX</B>;
  (* Returns the arctangent of z *)

<B>PROCEDURE</B> polarToComplex (abs, arg: <B>LONGREAL</B>): <B>LONGCOMPLEX</B>;
  (* Returns the complex number with the specified polar coordinates *)

<B>PROCEDURE</B> scalarMult (scalar: <B>LONGREAL</B>; z: <B>LONGCOMPLEX</B>): <B>LONGCOMPLEX</B>;
  (* Returns the scalar product of scalar with z *)

<B>PROCEDURE</B> IsCMathException (): <B>BOOLEAN</B>;
  (* Returns TRUE if the current coroutine is in the exceptional execution state  because of the raising of an exception in a routine from this module; otherwise returns FALSE. *)

<B>END</B> LongComplexMath.</PRE><HR><CENTER><A HREF="../contents.html" TARGET="big_right">Contents</A></CENTER></BODY></HTML>