<?xml version="1.0"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>How to Think Like a Computer Scientist: Strings</title><link href="stylesheet.css" type="text/css" rel="stylesheet" /></head><body bgcolor="white"><h1 class="title">Strings</h1><div class="toc"><ol><li><a href="#auto0">A compound data type</a></li><li><a href="#auto1">Length</a></li><li><a href="#auto2">Traversal and the for loop</a></li><li><a href="#auto3">String slices</a></li><li><a href="#auto4">String comparison</a></li><li><a href="#auto5">Strings are immutable</a></li><li><a href="#auto6">A find function</a></li><li><a href="#auto7">Looping and counting</a></li><li><a href="#auto8">The string module</a></li><li><a href="#auto9">Character classification</a></li><li><a href="#auto10">Glossary</a></li><li><a href="#auto11">Exercises</a></li></ol></div><div class="content"><span></span><a name="strings"></a><h2>A compound data type<a name="auto0"></a></h2><a name="index01"></a><a name="index02"></a><p>So far we have seen five types: <code>int</code>, <code>float</code>, 
<code>bool</code>, <code>NoneType</code> and <code>str</code>.  Strings are
qualitatively different from the other four because they are made up of smaller 
pieces---characters.</p><a name="index03"></a><p>Types that comprise smaller pieces are called <strong>compound data
types</strong>.  Depending on what we are doing, we may want to treat a
compound data type as a single thing, or we may want to access its parts. This
ambiguity is useful.</p><a name="index04"></a><a name="index05"></a><p>The bracket operator selects a single character from a string.</p><pre class="python-interpreter">
&gt;&gt;&gt; fruit = &quot;banana&quot;
&gt;&gt;&gt; letter = fruit[1]
&gt;&gt;&gt; print letter
</pre><p>The expression <code>fruit[1]</code> selects character number 1 from
<code>fruit</code>.  The variable <code>letter</code> refers to the result.
When we display <code>letter</code>, we get a surprise:</p><pre class="python-interpreter">
a
</pre><p>The first letter of <code>&quot;banana&quot;</code> is not <code>a</code>.  Unless you 
are a computer scientist.  For perverse reasons, computer scientists always
start counting from zero.  The 0th letter (<q>zero-eth</q>) of
<code>&quot;banana&quot;</code> is <code>b</code>.  The 1th letter (<q>one-eth</q>) is
<code>a</code>, and the 2th (<q>two-eth</q>) letter is <code>n</code>.</p><p>If you want the zero-eth letter of a string, you just put 0, or any
expression with the value 0, in the brackets:</p><pre class="python-interpreter">
&gt;&gt;&gt; letter = fruit[0]
&gt;&gt;&gt; print letter
b
</pre><p>The expression in brackets is called an <strong>index</strong>.  An index
specifies a member of an ordered set, in this case the set of characters in the 
string.  The index <em>indicates</em> which one you want, hence the name.  It
can be any integer expression.</p><a name="index06"></a><h2>Length<a name="auto1"></a></h2><a name="index07"></a><a name="index08"></a><p>The <code>len</code> function returns the number of characters in a string:
</p><pre class="python-interpreter">
&gt;&gt;&gt; fruit = &quot;banana&quot;
&gt;&gt;&gt; len(fruit)
6
</pre><p>To get the last letter of a string, you might be tempted to try something
like this:</p><pre class="python">
<span class="py-src-variable">length</span> = <span class="py-src-variable">len</span>(<span class="py-src-variable">fruit</span>)
<span class="py-src-variable">last</span> = <span class="py-src-variable">fruit</span>[<span class="py-src-variable">length</span>]       <span class="py-src-comment"># ERROR!</span>
</pre><p>That won't work. It causes the runtime error
<code class="shell">IndexError: string index out of range</code>.  The reason
is that there is no 6th letter in <code>&quot;banana&quot;</code>.  Since we started
counting at zero, the six letters are numbered 0 to 5.  To get the last
character, we have to subtract 1 from <code>length</code>:</p><a name="index09"></a><pre class="python">
<span class="py-src-variable">length</span> = <span class="py-src-variable">len</span>(<span class="py-src-variable">fruit</span>)
<span class="py-src-variable">last</span> = <span class="py-src-variable">fruit</span>[<span class="py-src-variable">length</span>-<span class="py-src-number">1</span>]
</pre><p>Alternatively, we can use negative indices, which count backward from the
end of the string.  The expression <code>fruit[-1]</code> yields the last
letter, <code>fruit[-2]</code> yields the second to last, and so on.</p><a name="index10"></a><h2>Traversal and the <code>for</code> loop<a name="auto2"></a></h2><a name="for"></a><a name="index11"></a><a name="index12"></a><a name="index13"></a><a name="index14"></a><p>A lot of computations involve processing a string one character at a time.
Often they start at the beginning, select each character in turn, do something
to it, and continue until the end.  This pattern of processing is called a
<strong>traversal</strong>.  One way to encode a traversal is with a
<code>while</code> statement:</p><pre class="python">
<span class="py-src-variable">index</span> = <span class="py-src-number">0</span>
<span class="py-src-keyword">while</span> <span class="py-src-variable">index</span> &lt; <span class="py-src-variable">len</span>(<span class="py-src-variable">fruit</span>):
<span class="py-src-variable">letter</span> = <span class="py-src-variable">fruit</span>[<span class="py-src-variable">index</span>]
<span class="py-src-keyword">print</span> <span class="py-src-variable">letter</span>
<span class="py-src-variable">index</span> = <span class="py-src-variable">index</span> + <span class="py-src-number">1</span>
</pre><p>This loop traverses the string and displays each letter on a line by itself. 
The loop condition is <code>index &lt; len(fruit)</code>, so when
<code>index</code> is equal to the length of the string, the condition is false,
and the body of the loop is not executed.  The last character accessed is the
one with the index <code>len(fruit)-1</code>, which is the last character in
the string.</p><p>Using an index to traverse a set of values is so common that Python provides 
an alternative, simpler syntax---the <code>for</code> loop:</p><pre class="python">
<span class="py-src-keyword">for</span> <span class="py-src-variable">char</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">fruit</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">char</span>
</pre><p>Each time through the loop, the next character in the string is assigned
to the variable <code>char</code>.  The loop continues until no characters are
left.</p><a name="index15"></a><a name="index16"></a><a name="index17"></a><a name="index18"></a><p>The following example shows how to use concatenation and a <code>for</code>
loop to generate an abecedarian series.  <q>Abecedarian</q> refers to a series
or list in which the elements appear in alphabetical order.  For example, in
Robert McCloskey's book <em>Make Way for Ducklings</em>, the names of the
ducklings are Jack, Kack, Lack, Mack, Nack, Ouack, Pack, and Quack.  This loop
outputs these names in order:</p><pre class="python">
<span class="py-src-variable">prefixes</span> = <span class="py-src-string">&quot;JKLMNOPQ&quot;</span>
<span class="py-src-variable">suffix</span> = <span class="py-src-string">&quot;ack&quot;</span>
   
<span class="py-src-keyword">for</span> <span class="py-src-variable">letter</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">prefixes</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">letter</span> + <span class="py-src-variable">suffix</span>
</pre><p>The output of this program is:</p><pre class="shell">
Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
</pre><p>Of course, that's not quite right because <q>Ouack</q> and <q>Quack</q> are
misspelled.  You'll fix this as an exercise below.</p><h2>String slices<a name="auto3"></a></h2><a name="slice"></a><a name="index19"></a><a name="index20"></a><p>A segment of a string is called a <strong>slice</strong>.  Selecting a slice 
is similar to selecting a character:</p><pre class="python-interpreter">
&gt;&gt;&gt; s = &quot;Peter, Paul, and Mary&quot;
&gt;&gt;&gt; print s[0:5]
Peter
&gt;&gt;&gt; print s[7:11]
Paul
&gt;&gt;&gt; print s[17:21]
Mary
</pre><p>The operator <code>[n:m]</code> returns the part of the string from the
<q>n-eth</q> character to the <q>m-eth</q> character, including the first but
excluding the last.  This behavior is counterintuitive; it makes more sense if
you imagine the indices pointing <em>between</em> the characters, as in the
following diagram:</p><img src="illustrations/banana.png" /><p>If you omit the first index (before the colon), the slice starts at the
beginning of the string.  If you omit the second index, the slice goes to the
end of the string.  Thus:</p><pre class="python-interpreter">
&gt;&gt;&gt; fruit = &quot;banana&quot;
&gt;&gt;&gt; fruit[:3]
'ban'
&gt;&gt;&gt; fruit[3:]
'ana'
</pre><p>What do you think <code>s[:]</code> means?</p><h2>String comparison<a name="auto4"></a></h2><a name="index21"></a><a name="index22"></a><p>The comparison operators work on strings.  To see if two strings are equal:
</p><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">word</span> == <span class="py-src-string">&quot;banana&quot;</span>:
    <span class="py-src-keyword">print</span>  <span class="py-src-string">&quot;Yes, we have no bananas!&quot;</span>
</pre><p>Other comparison operations are useful for putting words in alphabetical
order:</p><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">word</span> &lt; <span class="py-src-string">&quot;banana&quot;</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Your word,&quot;</span> + <span class="py-src-variable">word</span> + <span class="py-src-string">&quot;, comes before banana.&quot;</span>
<span class="py-src-keyword">elif</span> <span class="py-src-variable">word</span> &gt; <span class="py-src-string">&quot;banana&quot;</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Your word,&quot;</span> + <span class="py-src-variable">word</span> + <span class="py-src-string">&quot;, comes after banana.&quot;</span>
<span class="py-src-keyword">else</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Yes, we have no bananas!&quot;</span>
</pre><p>You should be aware, though, that Python does not handle upper- and
lowercase letters the same way that people do.  All the uppercase letters come
before all the lowercase letters.  As a result:</p><pre class="shell">
Your word, Zebra, comes before banana.
</pre><p>A common way to address this problem is to convert strings to a standard
format, such as all lowercase, before performing the comparison.  A more
difficult problem is making the program realize that zebras are not fruit.</p><h2>Strings are immutable<a name="auto5"></a></h2><a name="index23"></a><a name="index24"></a><a name="index25"></a><p>It is tempting to use the <code>[]</code> operator on the left side of an
assignment, with the intention of changing a character in a string.  For
example:</p><pre class="python">
<span class="py-src-variable">greeting</span> = <span class="py-src-string">&quot;Hello, world!&quot;</span>
<span class="py-src-variable">greeting</span>[<span class="py-src-number">0</span>] = <span class="py-src-string">'J'</span>            <span class="py-src-comment"># ERROR!</span>
<span class="py-src-keyword">print</span> <span class="py-src-variable">greeting</span>
</pre><p>Instead of producing the output <code>Jello, world!</code>, this code
produces the runtime error
<code class="shell">TypeError: 'str' object doesn't support item assignment</code>.
</p><a name="index26"></a><p>Strings are <strong>immutable</strong>, which means you can't change an
existing string.  The best you can do is create a new string that is a
variation on the original:</p><pre class="python">
<span class="py-src-variable">greeting</span> = <span class="py-src-string">&quot;Hello, world!&quot;</span>
<span class="py-src-variable">newGreeting</span> = <span class="py-src-string">'J'</span> + <span class="py-src-variable">greeting</span>[<span class="py-src-number">1</span>:]
<span class="py-src-keyword">print</span> <span class="py-src-variable">newGreeting</span>
</pre><p>The solution here is to concatenate a new first letter onto a slice of
<code>greeting</code>.  This operation has no effect on the original string.
</p><a name="index27"></a><h2>A <code>find</code> function<a name="auto6"></a></h2><a name="find"></a><a name="index28"></a><a name="index29"></a><a name="index30"></a><a name="index31"></a><p>What does the following function do?</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">find</span>(<span class="py-src-parameter">strng</span>, <span class="py-src-parameter">ch</span>):
    <span class="py-src-variable">index</span> = <span class="py-src-number">0</span>
    <span class="py-src-keyword">while</span> <span class="py-src-variable">index</span> &lt; <span class="py-src-variable">len</span>(<span class="py-src-variable">strng</span>):
        <span class="py-src-keyword">if</span> <span class="py-src-variable">strng</span>[<span class="py-src-variable">index</span>] == <span class="py-src-variable">ch</span>:
            <span class="py-src-keyword">return</span> <span class="py-src-variable">index</span>
        <span class="py-src-variable">index</span> = <span class="py-src-variable">index</span> + <span class="py-src-number">1</span>
    <span class="py-src-keyword">return</span> -<span class="py-src-number">1</span>
</pre><p>In a sense, <code>find</code> is the opposite of the <code>[]</code>
operator.  Instead of taking an index and extracting the corresponding
character, it takes a character and finds the index where that character
appears.  If the character is not found, the function returns
<code>-1</code>.</p><p>This is the first example we have seen of a <code>return</code> statement
inside a loop.  If <code>strng[index] == ch</code>, the function returns
immediately, breaking out of the loop prematurely.</p><p>If the character doesn't appear in the string, then the program exits the
loop normally and returns <code>-1</code>.</p><p>This pattern of computation is sometimes called a <q>eureka</q> traversal
because as soon as we find what we are looking for, we can cry <q>Eureka!</q>
and stop looking.</p><h2>Looping and counting<a name="auto7"></a></h2><a name="counter"></a><a name="index32"></a><a name="index33"></a><p>The following program counts the number of times the letter <code>a</code>
appears in a string:</p><pre class="python">
<span class="py-src-variable">fruit</span> = <span class="py-src-string">&quot;banana&quot;</span>
<span class="py-src-variable">count</span> = <span class="py-src-number">0</span>
<span class="py-src-keyword">for</span> <span class="py-src-variable">char</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">fruit</span>:
    <span class="py-src-keyword">if</span> <span class="py-src-variable">char</span> == <span class="py-src-string">'a'</span>:
        <span class="py-src-variable">count</span> = <span class="py-src-variable">count</span> + <span class="py-src-number">1</span>
<span class="py-src-keyword">print</span> <span class="py-src-variable">count</span>
</pre><p>This program demonstrates another pattern of computation called a
<strong>counter</strong>.  The variable <code>count</code> is initialized to 0
and then incremented each time an <code>a</code> is found.
(To <strong>increment</strong> is to increase by one; it is the opposite of
<strong>decrement</strong>, and unrelated to <q>excrement,</q> which is a noun.)
When the loop exits, <code>count</code> contains the result---the total number
of <code>a</code>'s.</p><h2>The <code>string</code> module<a name="auto8"></a></h2><a name="index34"></a><a name="index35"></a><p>The <code>string</code> module contains useful functions that manipulate
strings.  As usual, we have to import the module before we can use it:</p><pre class="python-interpreter">
&gt;&gt;&gt; import string
</pre><p>The <code>string</code> module includes a function named <code>find</code>
that does the same thing as the function we wrote.  To call it we have to
specify the name of the module and the name of the function using dot notation.
</p><pre class="python-interpreter">
&gt;&gt;&gt; fruit = &quot;banana&quot;
&gt;&gt;&gt; index = string.find(fruit, &quot;a&quot;)
&gt;&gt;&gt; print index
1
</pre><p>This example demonstrates one of the benefits of modules---they help
avoid collisions between the names of built-in functions and user-defined
functions.  By using dot notation we can specify which version of
<code>find</code> we want.</p><p>Actually, <code>string.find</code> is more general than our version.  First,
it can find substrings, not just characters:</p><pre class="python-interpreter">
&gt;&gt;&gt; string.find(&quot;banana&quot;, &quot;na&quot;)
2
</pre><p>Also, it takes an additional argument that specifies the index it should
start at:</p><pre class="python-interpreter">
&gt;&gt;&gt; string.find(&quot;banana&quot;, &quot;na&quot;, 3)
4
</pre><p>Or it can take two additional arguments that specify a range of indices:</p><pre class="python-interpreter">
&gt;&gt;&gt; string.find(&quot;bob&quot;, &quot;b&quot;, 1, 2)
-1
</pre><p>In this example, the search fails because the letter <em>b</em> does not
appear in the index range from <code>1</code> to <code>2</code> (not including
<code>2</code>).</p><h2>Character classification<a name="auto9"></a></h2><a name="in"></a><a name="index36"></a><a name="index37"></a><a name="index38"></a><a name="index39"></a><a name="index40"></a><p>It is often helpful to examine a character and test whether it is upper- or
lowercase, or whether it is a character or a digit.  The <code>string</code>
module provides several constants that are useful for these purposes.</p><p>The string <code>string.lowercase</code> contains all of the letters that
the system considers to be lowercase.  Similarly, <code>string.uppercase</code>
contains all of the uppercase letters.  Try the following and see what you get:
</p><pre class="python-interpreter">
&gt;&gt;&gt; print string.lowercase
&gt;&gt;&gt; print string.uppercase
&gt;&gt;&gt; print string.digits
</pre><p>We can use these constants and <code>find</code> to classify characters. For
example, if <code>find(lowercase, ch)</code> returns a value other than
<code>-1</code>, then <code>ch</code> must be lowercase:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">isLower</span>(<span class="py-src-parameter">ch</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-variable">string</span>.<span class="py-src-variable">find</span>(<span class="py-src-variable">string</span>.<span class="py-src-variable">lowercase</span>, <span class="py-src-variable">ch</span>) != -<span class="py-src-number">1</span>
</pre><p>Alternatively, we can take advantage of the <code>in</code> operator, which
determines whether a character appears in a string:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">isLower</span>(<span class="py-src-parameter">ch</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-variable">ch</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">string</span>.<span class="py-src-variable">lowercase</span>
</pre><p>As yet another alternative, we can use the comparison operator:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">isLower</span>(<span class="py-src-parameter">ch</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-string">'a'</span> &lt;= <span class="py-src-variable">ch</span> &lt;= <span class="py-src-string">'z'</span>
</pre><p>If <code>ch</code> is between <em>a</em> and <em>z</em>, it must be a
lowercase letter.</p><p>Another constant defined in the <code>string</code> module may surprise you
when you print it:</p><pre class="python-interpreter">
&gt;&gt;&gt; print string.whitespace
</pre><p><strong>Whitespace</strong> characters move the cursor without printing
anything.  They create the white space between visible characters (at least on
white paper).  The constant <code>string.whitespace</code> contains all the
whitespace characters, including space, tab (\t), and newline (\n).</p><a name="index41"></a><a name="index42"></a><p>There are other useful functions in the <code>string</code> module, but this
book isn't intended to be a reference manual.  On the other hand, the
<em>Python Library Reference</em> is.  Along with a wealth of other
documentation, it's available from the Python website, 
<a href="http://www.python.org">http://www.python.org</a>.</p><a name="index43"></a><h2>Glossary<a name="auto10"></a></h2><a name="index44"></a><a name="index45"></a><a name="index46"></a><a name="index47"></a><a name="index48"></a><a name="index49"></a><a name="index50"></a><a name="index51"></a><a name="index52"></a><dl><dt>compound data type:</dt><dd>A data type in which the values are made up of components, or elements,
that are themselves values.</dd><dt>traverse:</dt><dd>To iterate through the elements of a set, performing a similar operation on 
each.</dd><dt>index:</dt><dd>A variable or value used to select a member of an ordered set, such as a
character from a string.</dd><dt>slice:</dt><dd>A part of a string specified by a range of indices.</dd><dt>mutable:</dt><dd>A compound data types whose elements can be assigned new values.</dd><dt>counter:</dt><dd>A variable used to count something, usually initialized to zero and then
incremented.</dd><dt>increment:</dt><dd>To increase the value of a variable by one.</dd><dt>decrement:</dt><dd>To decrease the value of a variable by one.</dd><dt>whitespace:</dt><dd>Any of the characters that move the cursor without printing visible
characters.  The constant <code>string.whitespace</code> contains all the
white-space characters.</dd></dl><h2>Exercises<a name="auto11"></a></h2><ol><li><div class="exercise">
Write a function that takes a string as an argument and outputs the letters
backward, one per line.
</div></li><li><div class="exercise">
Modify:
<pre class="python">
<span class="py-src-variable">prefixes</span> = <span class="py-src-string">&quot;JKLMNOPQ&quot;</span>
<span class="py-src-variable">suffix</span> = <span class="py-src-string">&quot;ack&quot;</span>
   
<span class="py-src-keyword">for</span> <span class="py-src-variable">letter</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">prefixes</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">letter</span> + <span class="py-src-variable">suffix</span>
</pre>
so that <code>Ouack</code> and <code>Quack</code> are spelled correctly.
</div></li><li><div class="exercise">
Modify the <code>find</code> function so that it takes a third parameter, the
index in the string where it should start looking.
</div></li><li><div class="exercise">
Encapsulate
<pre class="python">
<span class="py-src-variable">fruit</span> = <span class="py-src-string">&quot;banana&quot;</span>
<span class="py-src-variable">count</span> = <span class="py-src-number">0</span>
<span class="py-src-keyword">for</span> <span class="py-src-variable">char</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">fruit</span>:
    <span class="py-src-keyword">if</span> <span class="py-src-variable">char</span> == <span class="py-src-string">'a'</span>:
    <span class="py-src-variable">count</span> = <span class="py-src-variable">count</span> + <span class="py-src-number">1</span>
<span class="py-src-keyword">print</span> <span class="py-src-variable">count</span>
</pre>
in a function named <code>countLetters</code>, and generalize it so that it
accepts the string and the letter as arguments.
</div></li><li><div class="exercise">
Now rewrite the <code>countLetters</code> function so that instead of
traversing the string, it uses your three-parameter version of
<code>find</code>.
</div></li><li><div class="exercise">
Which version of <code>isLower</code> do you think will be fastest?  Can you
think of other reasons besides speed to prefer one version or the other?
</div></li></ol></div><p><a href="index.html">Table of Contents</a> |
    <a href="dex.html">Index</a></p></body></html>